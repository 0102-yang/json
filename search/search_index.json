{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"JSON for Modern C++ \u00b6 Note This page is under construction. You probably want to see the Doxygen documentation .","title":"JSON for Modern C++"},{"location":"#json-for-modern-c","text":"Note This page is under construction. You probably want to see the Doxygen documentation .","title":"JSON for Modern C++"},{"location":"features/arbitrary_types/","text":"Arbitrary Types Conversions \u00b6 Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines: namespace ns { // a simple struct to model a person struct person { std :: string name ; std :: string address ; int age ; }; } ns :: person p = { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // convert to JSON: copy each value into the JSON object json j ; j [ \"name\" ] = p . name ; j [ \"address\" ] = p . address ; j [ \"age\" ] = p . age ; // ... // convert from JSON: copy each value from the JSON object ns :: person p { j [ \"name\" ]. get < std :: string > (), j [ \"address\" ]. get < std :: string > (), j [ \"age\" ]. get < int > () }; It works, but that's quite a lot of boilerplate... Fortunately, there's a better way: // create a person ns :: person p { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // conversion: person -> json json j = p ; std :: cout << j << std :: endl ; // {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"} // conversion: json -> person auto p2 = j . get < ns :: person > (); // that's it assert ( p == p2 ); Basic usage \u00b6 To make this work with one of your types, you only need to provide two functions: using nlohmann :: json ; namespace ns { void to_json ( json & j , const person & p ) { j = json { { \"name\" , p . name }, { \"address\" , p . address }, { \"age\" , p . age } }; } void from_json ( const json & j , person & p ) { j . at ( \"name\" ). get_to ( p . name ); j . at ( \"address\" ). get_to ( p . address ); j . at ( \"age\" ). get_to ( p . age ); } } // namespace ns That's all! When calling the json constructor with your type, your custom to_json method will be automatically called. Likewise, when calling get<your_type>() or get_to(your_type&) , the from_json method will be called. Some important things: Those methods MUST be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace ns , where person is defined). Those methods MUST be available (e.g., proper headers must be included) everywhere you use these conversions. Look at issue 1108 for errors that may occur otherwise. When using get<your_type>() , your_type MUST be DefaultConstructible . (There is a way to bypass this requirement described later.) In function from_json , use function at() to access the object values rather than operator[] . In case a key does not exist, at throws an exception that you can handle, whereas operator[] exhibits undefined behavior. You do not need to add serializers or deserializers for STL types like std::vector : the library already implements these. How do I convert third-party types? \u00b6 This requires a bit more advanced technique. But first, let's see how this conversion mechanism works: The library uses JSON Serializers to convert types to json. The default serializer for nlohmann::json is nlohmann::adl_serializer (ADL means Argument-Dependent Lookup ). It is implemented like this (simplified): template < typename T > struct adl_serializer { static void to_json ( json & j , const T & value ) { // calls the \"to_json\" method in T's namespace } static void from_json ( const json & j , T & value ) { // same thing, but with the \"from_json\" method } }; This serializer works fine when you have control over the type's namespace. However, what about boost::optional or std::filesystem::path (C++17)? Hijacking the boost namespace is pretty bad, and it's illegal to add something other than template specializations to std ... To solve this, you need to add a specialization of adl_serializer to the nlohmann namespace, here's an example: // partial specialization (full specialization works too) namespace nlohmann { template < typename T > struct adl_serializer < boost :: optional < T >> { static void to_json ( json & j , const boost :: optional < T >& opt ) { if ( opt == boost :: none ) { j = nullptr ; } else { j = * opt ; // this will call adl_serializer<T>::to_json which will // find the free function to_json in T's namespace! } } static void from_json ( const json & j , boost :: optional < T >& opt ) { if ( j . is_null ()) { opt = boost :: none ; } else { opt = j . get < T > (); // same as above, but with // adl_serializer<T>::from_json } } }; } How can I use get() for non-default constructible/non-copyable types? \u00b6 There is a way, if your type is MoveConstructible . You will need to specialize the adl_serializer as well, but with a special from_json overload: struct move_only_type { move_only_type () = delete ; move_only_type ( int ii ) : i ( ii ) {} move_only_type ( const move_only_type & ) = delete ; move_only_type ( move_only_type && ) = default ; int i ; }; namespace nlohmann { template <> struct adl_serializer < move_only_type > { // note: the return type is no longer 'void', and the method only takes // one argument static move_only_type from_json ( const json & j ) { return { j . get < int > ()}; } // Here's the catch! You must provide a to_json method! Otherwise you // will not be able to convert move_only_type to json, since you fully // specialized adl_serializer on that type static void to_json ( json & j , move_only_type t ) { j = t . i ; } }; } Can I write my own serializer? (Advanced use) \u00b6 Yes. You might want to take a look at unit-udt.cpp in the test suite, to see a few examples. If you write your own serializer, you'll need to do a few things: use a different basic_json alias than nlohmann::json (the last template parameter of basic_json is the JSONSerializer ) use your basic_json alias (or a template parameter) in all your to_json / from_json methods use nlohmann::to_json and nlohmann::from_json when you need ADL Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL. // You should use void as a second template argument // if you don't need compile-time checks on T template < typename T , typename SFINAE = typename std :: enable_if < sizeof ( T ) <= 32 >:: type > struct less_than_32_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , T value ) { // we want to use ADL, and call the correct to_json overload using nlohmann :: to_json ; // this method is called by adl_serializer, // this is where the magic happens to_json ( j , value ); } template < typename BasicJsonType > static void from_json ( const BasicJsonType & j , T & value ) { // same thing here using nlohmann :: from_json ; from_json ( j , value ); } }; Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention: template < typename T , void > struct bad_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , const T & value ) { // this calls BasicJsonType::json_serializer<T>::to_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! j = value ; } template < typename BasicJsonType > static void to_json ( const BasicJsonType & j , T & value ) { // this calls BasicJsonType::json_serializer<T>::from_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! value = j . template get < T > (); // oops! } };","title":"Arbitrary Types Conversions"},{"location":"features/arbitrary_types/#arbitrary-types-conversions","text":"Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines: namespace ns { // a simple struct to model a person struct person { std :: string name ; std :: string address ; int age ; }; } ns :: person p = { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // convert to JSON: copy each value into the JSON object json j ; j [ \"name\" ] = p . name ; j [ \"address\" ] = p . address ; j [ \"age\" ] = p . age ; // ... // convert from JSON: copy each value from the JSON object ns :: person p { j [ \"name\" ]. get < std :: string > (), j [ \"address\" ]. get < std :: string > (), j [ \"age\" ]. get < int > () }; It works, but that's quite a lot of boilerplate... Fortunately, there's a better way: // create a person ns :: person p { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // conversion: person -> json json j = p ; std :: cout << j << std :: endl ; // {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"} // conversion: json -> person auto p2 = j . get < ns :: person > (); // that's it assert ( p == p2 );","title":"Arbitrary Types Conversions"},{"location":"features/arbitrary_types/#basic-usage","text":"To make this work with one of your types, you only need to provide two functions: using nlohmann :: json ; namespace ns { void to_json ( json & j , const person & p ) { j = json { { \"name\" , p . name }, { \"address\" , p . address }, { \"age\" , p . age } }; } void from_json ( const json & j , person & p ) { j . at ( \"name\" ). get_to ( p . name ); j . at ( \"address\" ). get_to ( p . address ); j . at ( \"age\" ). get_to ( p . age ); } } // namespace ns That's all! When calling the json constructor with your type, your custom to_json method will be automatically called. Likewise, when calling get<your_type>() or get_to(your_type&) , the from_json method will be called. Some important things: Those methods MUST be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace ns , where person is defined). Those methods MUST be available (e.g., proper headers must be included) everywhere you use these conversions. Look at issue 1108 for errors that may occur otherwise. When using get<your_type>() , your_type MUST be DefaultConstructible . (There is a way to bypass this requirement described later.) In function from_json , use function at() to access the object values rather than operator[] . In case a key does not exist, at throws an exception that you can handle, whereas operator[] exhibits undefined behavior. You do not need to add serializers or deserializers for STL types like std::vector : the library already implements these.","title":"Basic usage"},{"location":"features/arbitrary_types/#how-do-i-convert-third-party-types","text":"This requires a bit more advanced technique. But first, let's see how this conversion mechanism works: The library uses JSON Serializers to convert types to json. The default serializer for nlohmann::json is nlohmann::adl_serializer (ADL means Argument-Dependent Lookup ). It is implemented like this (simplified): template < typename T > struct adl_serializer { static void to_json ( json & j , const T & value ) { // calls the \"to_json\" method in T's namespace } static void from_json ( const json & j , T & value ) { // same thing, but with the \"from_json\" method } }; This serializer works fine when you have control over the type's namespace. However, what about boost::optional or std::filesystem::path (C++17)? Hijacking the boost namespace is pretty bad, and it's illegal to add something other than template specializations to std ... To solve this, you need to add a specialization of adl_serializer to the nlohmann namespace, here's an example: // partial specialization (full specialization works too) namespace nlohmann { template < typename T > struct adl_serializer < boost :: optional < T >> { static void to_json ( json & j , const boost :: optional < T >& opt ) { if ( opt == boost :: none ) { j = nullptr ; } else { j = * opt ; // this will call adl_serializer<T>::to_json which will // find the free function to_json in T's namespace! } } static void from_json ( const json & j , boost :: optional < T >& opt ) { if ( j . is_null ()) { opt = boost :: none ; } else { opt = j . get < T > (); // same as above, but with // adl_serializer<T>::from_json } } }; }","title":"How do I convert third-party types?"},{"location":"features/arbitrary_types/#how-can-i-use-get-for-non-default-constructiblenon-copyable-types","text":"There is a way, if your type is MoveConstructible . You will need to specialize the adl_serializer as well, but with a special from_json overload: struct move_only_type { move_only_type () = delete ; move_only_type ( int ii ) : i ( ii ) {} move_only_type ( const move_only_type & ) = delete ; move_only_type ( move_only_type && ) = default ; int i ; }; namespace nlohmann { template <> struct adl_serializer < move_only_type > { // note: the return type is no longer 'void', and the method only takes // one argument static move_only_type from_json ( const json & j ) { return { j . get < int > ()}; } // Here's the catch! You must provide a to_json method! Otherwise you // will not be able to convert move_only_type to json, since you fully // specialized adl_serializer on that type static void to_json ( json & j , move_only_type t ) { j = t . i ; } }; }","title":"How can I use get() for non-default constructible/non-copyable types?"},{"location":"features/arbitrary_types/#can-i-write-my-own-serializer-advanced-use","text":"Yes. You might want to take a look at unit-udt.cpp in the test suite, to see a few examples. If you write your own serializer, you'll need to do a few things: use a different basic_json alias than nlohmann::json (the last template parameter of basic_json is the JSONSerializer ) use your basic_json alias (or a template parameter) in all your to_json / from_json methods use nlohmann::to_json and nlohmann::from_json when you need ADL Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL. // You should use void as a second template argument // if you don't need compile-time checks on T template < typename T , typename SFINAE = typename std :: enable_if < sizeof ( T ) <= 32 >:: type > struct less_than_32_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , T value ) { // we want to use ADL, and call the correct to_json overload using nlohmann :: to_json ; // this method is called by adl_serializer, // this is where the magic happens to_json ( j , value ); } template < typename BasicJsonType > static void from_json ( const BasicJsonType & j , T & value ) { // same thing here using nlohmann :: from_json ; from_json ( j , value ); } }; Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention: template < typename T , void > struct bad_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , const T & value ) { // this calls BasicJsonType::json_serializer<T>::to_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! j = value ; } template < typename BasicJsonType > static void to_json ( const BasicJsonType & j , T & value ) { // this calls BasicJsonType::json_serializer<T>::from_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! value = j . template get < T > (); // oops! } };","title":"Can I write my own serializer? (Advanced use)"},{"location":"features/binary_values/","text":"Binary Values \u00b6 The library implements several binary formats that encode JSON in an efficient way. Most of these formats support binary values; that is, values that have semantics define outside the library and only define a sequence of bytes to be stored. JSON itself does not have a binary value. As such, binary values are an extension that this library implements to store values received by a binary format. Binary values are never created by the JSON parser, and are only part of a serialized JSON text if they have been created manually or via a binary format. API for binary values \u00b6 By default, binary values are stored as std::vector<std::uint8_t> . This type can be changed by providing a template parameter to the basic_json type. To store binary subtypes, the storage type is extended and exposed as json::binary_t : auto binary = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }); auto binary_with_subtype = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); There are several convenience functions to check and set the subtype: binary . has_subtype (); // returns false binary_with_subtype . has_subtype (); // returns true binary_with_subtype . clear_subtype (); binary_with_subtype . has_subtype (); // returns true binary_with_subtype . set_subtype ( 42 ); binary . set_subtype ( 23 ); binary . subtype (); // returns 23 As json::binary_t is subclassing std::vector<std::uint8_t> , all member functions are available: binary . size (); // returns 4 binary [ 1 ]; // returns 0xFE JSON values can be constructed from json::binary_t : json j = binary ; Binary values are primitive values just like numbers or strings: j . is_binary (); // returns true j . is_primitive (); // returns true Given a binary JSON value, the binary_t can be accessed by reference as via get_binary() : j . get_binary (). has_subtype (); // returns true j . get_binary (). size (); // returns 4 For convencience, binary JSON values can be constructed via json::binary : auto j2 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 23 ); auto j3 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }); j2 == j ; // returns true j3 . get_binary (). has_subtype (); // returns false Serialization \u00b6 Binary values are serialized differently according to the formats. JSON \u00b6 JSON does not have a binary type, and this library does not introduce a new type as this would break conformance. Instead, binary values are serialized as an object with two keys: bytes holds an array of integers, and subtype is an integer or null . Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // serialize to standard output std :: cout << j . dump ( 2 ) << std :: endl ; Output: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } No roundtrip for binary values The JSON parser will not parse the objects generated by binary values back to binary values. This is by design to remain standards compliant. Serializing binary values to JSON is only implemented for debugging purposes. BSON \u00b6 BSON supports binary values and subtypes. If a subtype is given, it is used and added as unsigned 8-bit integer. If no subtype is given, the generic binary subtype 0x00 is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to BSON auto v = json :: to_bson ( j ); v is a std::vector<std::uint8t> with the following 22 elements: 0x16 0x00 0x00 0x00 // number of bytes in the document 0x05 // binary value 0x62 0x69 0x6E 0x61 0x72 0x79 0x00 // key \"binary\" + null byte 0x04 0x00 0x00 0x00 // number of bytes 0x2a // subtype 0xCA 0xFE 0xBA 0xBE // content 0x00 // end of the document Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } CBOR \u00b6 CBOR supports binary values, but no subtypes. Any binary value will be serialized as byte strings. The library will choose the smallest representation using the length of the byte array. Example Code: // create a binary value of subtype 42 (will be ignored by CBOR) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to CBOR auto v = json :: to_cbor ( j ); v is a std::vector<std::uint8t> with the following 13 elements: 0xA1 // map(1) 0x66 // text(6) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x44 // bytes(4) 0xCA 0xFE 0xBA 0xBE // content Note the subtype (42) is not serialized, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : null } } MessagePack \u00b6 MessagePack supports binary values and subtypes. If a subtype is given, the ext family is used. The library will choose the smallest representation among fixext1, fixext2, fixext4, fixext8, ext8, ext16, and ext32. The subtype is then added as singed 8-bit integer. If no subtype is given, the bin family (bin8, bin16, bin32) is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to MessagePack auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 14 elements: 0x81 // fixmap1 0xA6 // fixstr6 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD6 // fixext4 0x2A // subtype 0xCA 0xFE 0xBA 0xBE // content Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } UBJSON \u00b6 UBJSON neither supports binary values nor subtypes, and proposes to serialize binary values as array of uint8 values. This translation is implemented by the library. Example Code: // create a binary value of subtype 42 (will be ignored in UBJSON) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to UBJSON auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 20 elements: 0x7B // '{' 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x5B // '[' 0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE // content (each byte prefixed with 'U') 0x5D // ']' 0x7D // '}' The following code uses the type and size optimization for UBJSON: // convert to UBJSON using the size and type optimization auto v = json :: to_ubjson ( j , true , true ); The resulting vector has 23 elements; the optimization is not effective for examples with few values: 0x7B // '{' 0x24 // '$' type of the object elements 0x5B // '[' array 0x23 0x69 0x01 // '#' i 1 number of object elements 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x24 0x55 // '$' 'U' type of the array elements: unsinged integers 0x23 0x69 0x04 // '#' i 4 number of array elements 0xCA 0xFE 0xBA 0xBE // content Note that subtype (42) is not serialized and that UBJSON has no binary type , and deserializing v would yield the following value: { \"binary\" : [ 202 , 254 , 186 , 190 ] }","title":"Binary Values"},{"location":"features/binary_values/#binary-values","text":"The library implements several binary formats that encode JSON in an efficient way. Most of these formats support binary values; that is, values that have semantics define outside the library and only define a sequence of bytes to be stored. JSON itself does not have a binary value. As such, binary values are an extension that this library implements to store values received by a binary format. Binary values are never created by the JSON parser, and are only part of a serialized JSON text if they have been created manually or via a binary format.","title":"Binary Values"},{"location":"features/binary_values/#api-for-binary-values","text":"By default, binary values are stored as std::vector<std::uint8_t> . This type can be changed by providing a template parameter to the basic_json type. To store binary subtypes, the storage type is extended and exposed as json::binary_t : auto binary = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }); auto binary_with_subtype = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); There are several convenience functions to check and set the subtype: binary . has_subtype (); // returns false binary_with_subtype . has_subtype (); // returns true binary_with_subtype . clear_subtype (); binary_with_subtype . has_subtype (); // returns true binary_with_subtype . set_subtype ( 42 ); binary . set_subtype ( 23 ); binary . subtype (); // returns 23 As json::binary_t is subclassing std::vector<std::uint8_t> , all member functions are available: binary . size (); // returns 4 binary [ 1 ]; // returns 0xFE JSON values can be constructed from json::binary_t : json j = binary ; Binary values are primitive values just like numbers or strings: j . is_binary (); // returns true j . is_primitive (); // returns true Given a binary JSON value, the binary_t can be accessed by reference as via get_binary() : j . get_binary (). has_subtype (); // returns true j . get_binary (). size (); // returns 4 For convencience, binary JSON values can be constructed via json::binary : auto j2 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 23 ); auto j3 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }); j2 == j ; // returns true j3 . get_binary (). has_subtype (); // returns false","title":"API for binary values"},{"location":"features/binary_values/#serialization","text":"Binary values are serialized differently according to the formats.","title":"Serialization"},{"location":"features/binary_values/#json","text":"JSON does not have a binary type, and this library does not introduce a new type as this would break conformance. Instead, binary values are serialized as an object with two keys: bytes holds an array of integers, and subtype is an integer or null . Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // serialize to standard output std :: cout << j . dump ( 2 ) << std :: endl ; Output: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } No roundtrip for binary values The JSON parser will not parse the objects generated by binary values back to binary values. This is by design to remain standards compliant. Serializing binary values to JSON is only implemented for debugging purposes.","title":"JSON"},{"location":"features/binary_values/#bson","text":"BSON supports binary values and subtypes. If a subtype is given, it is used and added as unsigned 8-bit integer. If no subtype is given, the generic binary subtype 0x00 is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to BSON auto v = json :: to_bson ( j ); v is a std::vector<std::uint8t> with the following 22 elements: 0x16 0x00 0x00 0x00 // number of bytes in the document 0x05 // binary value 0x62 0x69 0x6E 0x61 0x72 0x79 0x00 // key \"binary\" + null byte 0x04 0x00 0x00 0x00 // number of bytes 0x2a // subtype 0xCA 0xFE 0xBA 0xBE // content 0x00 // end of the document Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } }","title":"BSON"},{"location":"features/binary_values/#cbor","text":"CBOR supports binary values, but no subtypes. Any binary value will be serialized as byte strings. The library will choose the smallest representation using the length of the byte array. Example Code: // create a binary value of subtype 42 (will be ignored by CBOR) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to CBOR auto v = json :: to_cbor ( j ); v is a std::vector<std::uint8t> with the following 13 elements: 0xA1 // map(1) 0x66 // text(6) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x44 // bytes(4) 0xCA 0xFE 0xBA 0xBE // content Note the subtype (42) is not serialized, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : null } }","title":"CBOR"},{"location":"features/binary_values/#messagepack","text":"MessagePack supports binary values and subtypes. If a subtype is given, the ext family is used. The library will choose the smallest representation among fixext1, fixext2, fixext4, fixext8, ext8, ext16, and ext32. The subtype is then added as singed 8-bit integer. If no subtype is given, the bin family (bin8, bin16, bin32) is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to MessagePack auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 14 elements: 0x81 // fixmap1 0xA6 // fixstr6 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD6 // fixext4 0x2A // subtype 0xCA 0xFE 0xBA 0xBE // content Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } }","title":"MessagePack"},{"location":"features/binary_values/#ubjson","text":"UBJSON neither supports binary values nor subtypes, and proposes to serialize binary values as array of uint8 values. This translation is implemented by the library. Example Code: // create a binary value of subtype 42 (will be ignored in UBJSON) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to UBJSON auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 20 elements: 0x7B // '{' 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x5B // '[' 0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE // content (each byte prefixed with 'U') 0x5D // ']' 0x7D // '}' The following code uses the type and size optimization for UBJSON: // convert to UBJSON using the size and type optimization auto v = json :: to_ubjson ( j , true , true ); The resulting vector has 23 elements; the optimization is not effective for examples with few values: 0x7B // '{' 0x24 // '$' type of the object elements 0x5B // '[' array 0x23 0x69 0x01 // '#' i 1 number of object elements 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x24 0x55 // '$' 'U' type of the array elements: unsinged integers 0x23 0x69 0x04 // '#' i 4 number of array elements 0xCA 0xFE 0xBA 0xBE // content Note that subtype (42) is not serialized and that UBJSON has no binary type , and deserializing v would yield the following value: { \"binary\" : [ 202 , 254 , 186 , 190 ] }","title":"UBJSON"},{"location":"features/enum_conversion/","text":"Specializing enum conversion \u00b6 By default, enum values are serialized to JSON as integers. In some cases this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later de-serialized JSON data may be undefined or a different enum value than was originally intended. It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below: // example enum type declaration enum TaskState { TS_STOPPED , TS_RUNNING , TS_COMPLETED , TS_INVALID =- 1 , }; // map TaskState values to JSON as strings NLOHMANN_JSON_SERIALIZE_ENUM ( TaskState , { { TS_INVALID , nullptr }, { TS_STOPPED , \"stopped\" }, { TS_RUNNING , \"running\" }, { TS_COMPLETED , \"completed\" }, }) The NLOHMANN_JSON_SERIALIZE_ENUM() macro declares a set of to_json() / from_json() functions for type TaskState while avoiding repetition and boilerplate serialization code. Usage \u00b6 // enum to JSON as string json j = TS_STOPPED ; assert ( j == \"stopped\" ); // json string to enum json j3 = \"running\" ; assert ( j3 . get < TaskState > () == TS_RUNNING ); // undefined json value to enum (where the first map entry above is the default) json jPi = 3.14 ; assert ( jPi . get < TaskState > () == TS_INVALID ); Notes \u00b6 Just as in Arbitrary Type Conversions above, NLOHMANN_JSON_SERIALIZE_ENUM() MUST be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it and it will default to integer serialization. It MUST be available (e.g., proper headers must be included) everywhere you use the conversions. Other Important points: When using get<ENUM_TYPE>() , undefined JSON values will default to the first pair specified in your map. Select this default pair carefully. If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON.","title":"Specializing enum conversion"},{"location":"features/enum_conversion/#specializing-enum-conversion","text":"By default, enum values are serialized to JSON as integers. In some cases this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later de-serialized JSON data may be undefined or a different enum value than was originally intended. It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below: // example enum type declaration enum TaskState { TS_STOPPED , TS_RUNNING , TS_COMPLETED , TS_INVALID =- 1 , }; // map TaskState values to JSON as strings NLOHMANN_JSON_SERIALIZE_ENUM ( TaskState , { { TS_INVALID , nullptr }, { TS_STOPPED , \"stopped\" }, { TS_RUNNING , \"running\" }, { TS_COMPLETED , \"completed\" }, }) The NLOHMANN_JSON_SERIALIZE_ENUM() macro declares a set of to_json() / from_json() functions for type TaskState while avoiding repetition and boilerplate serialization code.","title":"Specializing enum conversion"},{"location":"features/enum_conversion/#usage","text":"// enum to JSON as string json j = TS_STOPPED ; assert ( j == \"stopped\" ); // json string to enum json j3 = \"running\" ; assert ( j3 . get < TaskState > () == TS_RUNNING ); // undefined json value to enum (where the first map entry above is the default) json jPi = 3.14 ; assert ( jPi . get < TaskState > () == TS_INVALID );","title":"Usage"},{"location":"features/enum_conversion/#notes","text":"Just as in Arbitrary Type Conversions above, NLOHMANN_JSON_SERIALIZE_ENUM() MUST be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it and it will default to integer serialization. It MUST be available (e.g., proper headers must be included) everywhere you use the conversions. Other Important points: When using get<ENUM_TYPE>() , undefined JSON values will default to the first pair specified in your map. Select this default pair carefully. If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON.","title":"Notes"},{"location":"features/json_patch/","text":"JSON Patch \u00b6 On top of this, JSON Patch ( RFC 6902 ) allows to describe differences between two JSON values - effectively allowing patch and diff operations known from Unix. // a JSON patch (RFC 6902) json j_patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json j_result = j_original . patch ( j_patch ); // { // \"baz\": \"boo\", // \"hello\": [\"world\"] // } // calculate a JSON patch from two JSON values json :: diff ( j_result , j_original ); // [ // { \"op\":\" replace\", \"path\": \"/baz\", \"value\": [\"one\", \"two\", \"three\"] }, // { \"op\": \"remove\",\"path\": \"/hello\" }, // { \"op\": \"add\", \"path\": \"/foo\", \"value\": \"bar\" } // ]","title":"JSON Patch"},{"location":"features/json_patch/#json-patch","text":"On top of this, JSON Patch ( RFC 6902 ) allows to describe differences between two JSON values - effectively allowing patch and diff operations known from Unix. // a JSON patch (RFC 6902) json j_patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json j_result = j_original . patch ( j_patch ); // { // \"baz\": \"boo\", // \"hello\": [\"world\"] // } // calculate a JSON patch from two JSON values json :: diff ( j_result , j_original ); // [ // { \"op\":\" replace\", \"path\": \"/baz\", \"value\": [\"one\", \"two\", \"three\"] }, // { \"op\": \"remove\",\"path\": \"/hello\" }, // { \"op\": \"add\", \"path\": \"/foo\", \"value\": \"bar\" } // ]","title":"JSON Patch"},{"location":"features/json_pointer/","text":"JSON Pointer \u00b6 The library supports JSON Pointer ( RFC 6901 ) as alternative means to address structured values. // a JSON value json j_original = R \" ( { \"baz\": [\"one\", \"two\", \"three\"], \"foo\": \"bar\" } ) \" _json ; // access members with a JSON pointer (RFC 6901) j_original [ \"/baz/1\" _json_pointer ]; // \"two\"","title":"JSON Pointer"},{"location":"features/json_pointer/#json-pointer","text":"The library supports JSON Pointer ( RFC 6901 ) as alternative means to address structured values. // a JSON value json j_original = R \" ( { \"baz\": [\"one\", \"two\", \"three\"], \"foo\": \"bar\" } ) \" _json ; // access members with a JSON pointer (RFC 6901) j_original [ \"/baz/1\" _json_pointer ]; // \"two\"","title":"JSON Pointer"},{"location":"features/merge_patch/","text":"JSON Merge Patch \u00b6 The library supports JSON Merge Patch ( RFC 7386 ) as a patch format. Instead of using JSON Pointer (see above) to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified. // a JSON value json j_document = R \" ( { \"a\": \"b\", \"c\": { \"d\": \"e\", \"f\": \"g\" } } ) \" _json ; // a patch json j_patch = R \" ( { \"a\":\"z\", \"c\": { \"f\": null } } ) \" _json ; // apply the patch j_document . merge_patch ( j_patch ); // { // \"a\": \"z\", // \"c\": { // \"d\": \"e\" // } // }","title":"JSON Merge Patch"},{"location":"features/merge_patch/#json-merge-patch","text":"The library supports JSON Merge Patch ( RFC 7386 ) as a patch format. Instead of using JSON Pointer (see above) to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified. // a JSON value json j_document = R \" ( { \"a\": \"b\", \"c\": { \"d\": \"e\", \"f\": \"g\" } } ) \" _json ; // a patch json j_patch = R \" ( { \"a\":\"z\", \"c\": { \"f\": null } } ) \" _json ; // apply the patch j_document . merge_patch ( j_patch ); // { // \"a\": \"z\", // \"c\": { // \"d\": \"e\" // } // }","title":"JSON Merge Patch"},{"location":"features/sax_interface/","text":"SAX Interface \u00b6 The library uses a SAX-like interface with the following functions: // called when null is parsed bool null (); // called when a boolean is parsed; value is passed bool boolean ( bool val ); // called when a signed or unsigned integer number is parsed; value is passed bool number_integer ( number_integer_t val ); bool number_unsigned ( number_unsigned_t val ); // called when a floating-point number is parsed; value and original string is passed bool number_float ( number_float_t val , const string_t & s ); // called when a string is parsed; value is passed and can be safely moved away bool string ( string_t & val ); // called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known) bool start_object ( std :: size_t elements ); bool end_object (); bool start_array ( std :: size_t elements ); bool end_array (); // called when an object key is parsed; value is passed and can be safely moved away bool key ( string_t & val ); // called when a parse error occurs; byte position, the last token, and an exception is passed bool parse_error ( std :: size_t position , const std :: string & last_token , const detail :: exception & ex ); The return value of each function determines whether parsing should proceed. To implement your own SAX handler, proceed as follows: Implement the SAX interface in a class. You can use class nlohmann::json_sax<json> as base class, but you can also use any class where the functions described above are implemented and public. Create an object of your SAX interface class, e.g. my_sax . Call bool json :: sax_parse ( input , & my_sax ); where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface. Note the sax_parse function only returns a bool indicating the result of the last executed SAX event. It does not return json value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your parse_error implementation. Internally, the SAX interface is used for the DOM parser (class json_sax_dom_parser ) as well as the acceptor ( json_sax_acceptor ), see file json_sax.hpp .","title":"SAX Interface"},{"location":"features/sax_interface/#sax-interface","text":"The library uses a SAX-like interface with the following functions: // called when null is parsed bool null (); // called when a boolean is parsed; value is passed bool boolean ( bool val ); // called when a signed or unsigned integer number is parsed; value is passed bool number_integer ( number_integer_t val ); bool number_unsigned ( number_unsigned_t val ); // called when a floating-point number is parsed; value and original string is passed bool number_float ( number_float_t val , const string_t & s ); // called when a string is parsed; value is passed and can be safely moved away bool string ( string_t & val ); // called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known) bool start_object ( std :: size_t elements ); bool end_object (); bool start_array ( std :: size_t elements ); bool end_array (); // called when an object key is parsed; value is passed and can be safely moved away bool key ( string_t & val ); // called when a parse error occurs; byte position, the last token, and an exception is passed bool parse_error ( std :: size_t position , const std :: string & last_token , const detail :: exception & ex ); The return value of each function determines whether parsing should proceed. To implement your own SAX handler, proceed as follows: Implement the SAX interface in a class. You can use class nlohmann::json_sax<json> as base class, but you can also use any class where the functions described above are implemented and public. Create an object of your SAX interface class, e.g. my_sax . Call bool json :: sax_parse ( input , & my_sax ); where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface. Note the sax_parse function only returns a bool indicating the result of the last executed SAX event. It does not return json value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your parse_error implementation. Internally, the SAX interface is used for the DOM parser (class json_sax_dom_parser ) as well as the acceptor ( json_sax_acceptor ), see file json_sax.hpp .","title":"SAX Interface"},{"location":"features/binary_formats/","text":"Overview \u00b6 Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports BSON (Binary JSON), CBOR (Concise Binary Object Representation), MessagePack , and UBJSON (Universal Binary JSON Specification) to efficiently encode JSON values to byte vectors and to decode such vectors. Comparison \u00b6 Completeness \u00b6 Format Serialization Deserialization BSON incomplete: top-level value must be an object incomplete, but all JSON types are supported CBOR complete incomplete, but all JSON types are supported MessagePack complete complete UBJSON complete complete Binary values \u00b6 Format Binary values Binary subtypes BSON supported supported CBOR supported not supported MessagePack supported supported UBJSON not supported not supported Sizes \u00b6 Format canada.json twitter.json citm_catalog.json jeopardy.json BSON 85,8 % 95,2 % 95,8 % 106,7 % CBOR 50,5 % 86,3 % 68,4 % 88,0 % MessagePack 50,6 % 86,0 % 68,5 % 87,9 % UBJSON 53,2 % 91,3 % 78,2 % 96,6 % UBJSON (size) 58,6 % 92,3 % 86,8 % 97,4 % UBJSON (size+type) 55,9 % 92,3 % 85,0 % 95,0 %","title":"Overview"},{"location":"features/binary_formats/#overview","text":"Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports BSON (Binary JSON), CBOR (Concise Binary Object Representation), MessagePack , and UBJSON (Universal Binary JSON Specification) to efficiently encode JSON values to byte vectors and to decode such vectors.","title":"Overview"},{"location":"features/binary_formats/#comparison","text":"","title":"Comparison"},{"location":"features/binary_formats/#completeness","text":"Format Serialization Deserialization BSON incomplete: top-level value must be an object incomplete, but all JSON types are supported CBOR complete incomplete, but all JSON types are supported MessagePack complete complete UBJSON complete complete","title":"Completeness"},{"location":"features/binary_formats/#binary-values","text":"Format Binary values Binary subtypes BSON supported supported CBOR supported not supported MessagePack supported supported UBJSON not supported not supported","title":"Binary values"},{"location":"features/binary_formats/#sizes","text":"Format canada.json twitter.json citm_catalog.json jeopardy.json BSON 85,8 % 95,2 % 95,8 % 106,7 % CBOR 50,5 % 86,3 % 68,4 % 88,0 % MessagePack 50,6 % 86,0 % 68,5 % 87,9 % UBJSON 53,2 % 91,3 % 78,2 % 96,6 % UBJSON (size) 58,6 % 92,3 % 86,8 % 97,4 % UBJSON (size+type) 55,9 % 92,3 % 85,0 % 95,0 %","title":"Sizes"},{"location":"features/binary_formats/bson/","text":"BSON \u00b6 BSON, short for Bin\u00adary JSON, is a bin\u00adary-en\u00adcoded seri\u00adal\u00adiz\u00ada\u00adtion of JSON-like doc\u00adu\u00adments. Like JSON, BSON sup\u00adports the em\u00adbed\u00adding of doc\u00adu\u00adments and ar\u00adrays with\u00adin oth\u00ader doc\u00adu\u00adments and ar\u00adrays. BSON also con\u00adtains ex\u00adten\u00adsions that al\u00adlow rep\u00adres\u00adent\u00ada\u00adtion of data types that are not part of the JSON spec. For ex\u00adample, BSON has a Date type and a BinData type. References BSON Website - the main source on BSON BSON Specification - the specification Serialization \u00b6 The library uses the following mapping from JSON values types to BSON types: JSON value type value/range BSON type marker null null null 0x0A boolean true , false boolean 0x08 number_integer -9223372036854775808..-2147483649 int64 0x12 number_integer -2147483648..2147483647 int32 0x10 number_integer 2147483648..9223372036854775807 int64 0x12 number_unsigned 0..2147483647 int32 0x10 number_unsigned 2147483648..9223372036854775807 int64 0x12 number_unsigned 9223372036854775808..18446744073709551615 -- -- number_float any value double 0x01 string any value string 0x02 array any value document 0x04 object any value document 0x03 binary any value binary 0x05 Incomplete mapping The mapping is incomplete , since only JSON-objects (and things contained therein) can be serialized to BSON. Also, integers larger than 9223372036854775807 cannot be serialized to BSON, and the keys may not contain U+0000, since they are serialized a zero-terminated c-strings. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00 Deserialization \u00b6 The library maps BSON record types to JSON value types as follows: BSON type BSON marker byte JSON value type double 0x01 number_float string 0x02 string document 0x03 object array 0x04 array binary 0x05 binary undefined 0x06 unsupported ObjectId 0x07 unsupported boolean 0x08 boolean UTC Date-Time 0x09 unsupported null 0x0A null Regular Expr. 0x0B unsupported DB Pointer 0x0C unsupported JavaScript Code 0x0D unsupported Symbol 0x0E unsupported JavaScript Code 0x0F unsupported int32 0x10 number_integer Timestamp 0x11 unsupported 128-bit decimal float 0x13 unsupported Max Key 0x7F unsupported Min Key 0xFF unsupported Incomplete mapping The mapping is incomplete . The unsupported mappings are indicated in the table above. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"BSON"},{"location":"features/binary_formats/bson/#bson","text":"BSON, short for Bin\u00adary JSON, is a bin\u00adary-en\u00adcoded seri\u00adal\u00adiz\u00ada\u00adtion of JSON-like doc\u00adu\u00adments. Like JSON, BSON sup\u00adports the em\u00adbed\u00adding of doc\u00adu\u00adments and ar\u00adrays with\u00adin oth\u00ader doc\u00adu\u00adments and ar\u00adrays. BSON also con\u00adtains ex\u00adten\u00adsions that al\u00adlow rep\u00adres\u00adent\u00ada\u00adtion of data types that are not part of the JSON spec. For ex\u00adample, BSON has a Date type and a BinData type. References BSON Website - the main source on BSON BSON Specification - the specification","title":"BSON"},{"location":"features/binary_formats/bson/#serialization","text":"The library uses the following mapping from JSON values types to BSON types: JSON value type value/range BSON type marker null null null 0x0A boolean true , false boolean 0x08 number_integer -9223372036854775808..-2147483649 int64 0x12 number_integer -2147483648..2147483647 int32 0x10 number_integer 2147483648..9223372036854775807 int64 0x12 number_unsigned 0..2147483647 int32 0x10 number_unsigned 2147483648..9223372036854775807 int64 0x12 number_unsigned 9223372036854775808..18446744073709551615 -- -- number_float any value double 0x01 string any value string 0x02 array any value document 0x04 object any value document 0x03 binary any value binary 0x05 Incomplete mapping The mapping is incomplete , since only JSON-objects (and things contained therein) can be serialized to BSON. Also, integers larger than 9223372036854775807 cannot be serialized to BSON, and the keys may not contain U+0000, since they are serialized a zero-terminated c-strings. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00","title":"Serialization"},{"location":"features/binary_formats/bson/#deserialization","text":"The library maps BSON record types to JSON value types as follows: BSON type BSON marker byte JSON value type double 0x01 number_float string 0x02 string document 0x03 object array 0x04 array binary 0x05 binary undefined 0x06 unsupported ObjectId 0x07 unsupported boolean 0x08 boolean UTC Date-Time 0x09 unsupported null 0x0A null Regular Expr. 0x0B unsupported DB Pointer 0x0C unsupported JavaScript Code 0x0D unsupported Symbol 0x0E unsupported JavaScript Code 0x0F unsupported int32 0x10 number_integer Timestamp 0x11 unsupported 128-bit decimal float 0x13 unsupported Max Key 0x7F unsupported Min Key 0xFF unsupported Incomplete mapping The mapping is incomplete . The unsupported mappings are indicated in the table above. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/cbor/","text":"CBOR \u00b6 The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. References CBOR Website - the main source on CBOR CBOR Playground - an interactive webpage to translate between JSON and CBOR RFC 7049 - the CBOR specification Serialization \u00b6 The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049): JSON value type value/range CBOR type first byte null null Null 0xF6 boolean true True 0xF5 boolean false False 0xF4 number_integer -9223372036854775808..-2147483649 Negative integer (8 bytes follow) 0x3B number_integer -2147483648..-32769 Negative integer (4 bytes follow) 0x3A number_integer -32768..-129 Negative integer (2 bytes follow) 0x39 number_integer -128..-25 Negative integer (1 byte follow) 0x38 number_integer -24..-1 Negative integer 0x20..0x37 number_integer 0..23 Integer 0x00..0x17 number_integer 24..255 Unsigned integer (1 byte follow) 0x18 number_integer 256..65535 Unsigned integer (2 bytes follow) 0x19 number_integer 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_integer 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_unsigned 0..23 Integer 0x00..0x17 number_unsigned 24..255 Unsigned integer (1 byte follow) 0x18 number_unsigned 256..65535 Unsigned integer (2 bytes follow) 0x19 number_unsigned 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_unsigned 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_float any value representable by a float Single-Precision Float 0xFA number_float any value NOT representable by a float Double-Precision Float 0xFB string length : 0..23 UTF-8 string 0x60..0x77 string length : 23..255 UTF-8 string (1 byte follow) 0x78 string length : 256..65535 UTF-8 string (2 bytes follow) 0x79 string length : 65536..4294967295 UTF-8 string (4 bytes follow) 0x7A string length : 4294967296..18446744073709551615 UTF-8 string (8 bytes follow) 0x7B array size : 0..23 array 0x80..0x97 array size : 23..255 array (1 byte follow) 0x98 array size : 256..65535 array (2 bytes follow) 0x99 array size : 65536..4294967295 array (4 bytes follow) 0x9A array size : 4294967296..18446744073709551615 array (8 bytes follow) 0x9B object size : 0..23 map 0xA0..0xB7 object size : 23..255 map (1 byte follow) 0xB8 object size : 256..65535 map (2 bytes follow) 0xB9 object size : 65536..4294967295 map (4 bytes follow) 0xBA object size : 4294967296..18446744073709551615 map (8 bytes follow) 0xBB binary size : 0..23 byte string 0x40..0x57 binary size : 23..255 byte string (1 byte follow) 0x58 binary size : 256..65535 byte string (2 bytes follow) 0x59 binary size : 65536..4294967295 byte string (4 bytes follow) 0x5A binary size : 4294967296..18446744073709551615 byte string (8 bytes follow) 0x5B Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a CBOR value. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the normal JSON serialization which serializes NaN or Infinity to null . Unused CBOR types The following CBOR types are not used in the conversion: UTF-8 strings terminated by \"break\" (0x7F) arrays terminated by \"break\" (0x9F) maps terminated by \"break\" (0xBF) byte strings terminated by \"break\" (0x5F) date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) tagged items (0xC6..0xD4, 0xD8..0xDB) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) half-precision floats (0xF9) break (0xFF) Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 Deserialization \u00b6 The library maps CBOR types to JSON value types as follows: CBOR type JSON value type first byte Integer number_unsigned 0x00..0x17 Unsigned integer number_unsigned 0x18 Unsigned integer number_unsigned 0x19 Unsigned integer number_unsigned 0x1A Unsigned integer number_unsigned 0x1B Negative integer number_integer 0x20..0x37 Negative integer number_integer 0x38 Negative integer number_integer 0x39 Negative integer number_integer 0x3A Negative integer number_integer 0x3B Byte string binary 0x40..0x57 Byte string binary 0x58 Byte string binary 0x59 Byte string binary 0x5A Byte string binary 0x5B UTF-8 string string 0x60..0x77 UTF-8 string string 0x78 UTF-8 string string 0x79 UTF-8 string string 0x7A UTF-8 string string 0x7B UTF-8 string string 0x7F array array 0x80..0x97 array array 0x98 array array 0x99 array array 0x9A array array 0x9B array array 0x9F map object 0xA0..0xB7 map object 0xB8 map object 0xB9 map object 0xBA map object 0xBB map object 0xBF False false 0xF4 True true 0xF5 Null null 0xF6 Half-Precision Float number_float 0xF9 Single-Precision Float number_float 0xFA Double-Precision Float number_float 0xFB Incomplete mapping The mapping is incomplete in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors: date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) tagged items (0xC6..0xD4, 0xD8..0xDB) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) Object keys CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"CBOR"},{"location":"features/binary_formats/cbor/#cbor","text":"The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. References CBOR Website - the main source on CBOR CBOR Playground - an interactive webpage to translate between JSON and CBOR RFC 7049 - the CBOR specification","title":"CBOR"},{"location":"features/binary_formats/cbor/#serialization","text":"The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049): JSON value type value/range CBOR type first byte null null Null 0xF6 boolean true True 0xF5 boolean false False 0xF4 number_integer -9223372036854775808..-2147483649 Negative integer (8 bytes follow) 0x3B number_integer -2147483648..-32769 Negative integer (4 bytes follow) 0x3A number_integer -32768..-129 Negative integer (2 bytes follow) 0x39 number_integer -128..-25 Negative integer (1 byte follow) 0x38 number_integer -24..-1 Negative integer 0x20..0x37 number_integer 0..23 Integer 0x00..0x17 number_integer 24..255 Unsigned integer (1 byte follow) 0x18 number_integer 256..65535 Unsigned integer (2 bytes follow) 0x19 number_integer 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_integer 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_unsigned 0..23 Integer 0x00..0x17 number_unsigned 24..255 Unsigned integer (1 byte follow) 0x18 number_unsigned 256..65535 Unsigned integer (2 bytes follow) 0x19 number_unsigned 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_unsigned 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_float any value representable by a float Single-Precision Float 0xFA number_float any value NOT representable by a float Double-Precision Float 0xFB string length : 0..23 UTF-8 string 0x60..0x77 string length : 23..255 UTF-8 string (1 byte follow) 0x78 string length : 256..65535 UTF-8 string (2 bytes follow) 0x79 string length : 65536..4294967295 UTF-8 string (4 bytes follow) 0x7A string length : 4294967296..18446744073709551615 UTF-8 string (8 bytes follow) 0x7B array size : 0..23 array 0x80..0x97 array size : 23..255 array (1 byte follow) 0x98 array size : 256..65535 array (2 bytes follow) 0x99 array size : 65536..4294967295 array (4 bytes follow) 0x9A array size : 4294967296..18446744073709551615 array (8 bytes follow) 0x9B object size : 0..23 map 0xA0..0xB7 object size : 23..255 map (1 byte follow) 0xB8 object size : 256..65535 map (2 bytes follow) 0xB9 object size : 65536..4294967295 map (4 bytes follow) 0xBA object size : 4294967296..18446744073709551615 map (8 bytes follow) 0xBB binary size : 0..23 byte string 0x40..0x57 binary size : 23..255 byte string (1 byte follow) 0x58 binary size : 256..65535 byte string (2 bytes follow) 0x59 binary size : 65536..4294967295 byte string (4 bytes follow) 0x5A binary size : 4294967296..18446744073709551615 byte string (8 bytes follow) 0x5B Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a CBOR value. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the normal JSON serialization which serializes NaN or Infinity to null . Unused CBOR types The following CBOR types are not used in the conversion: UTF-8 strings terminated by \"break\" (0x7F) arrays terminated by \"break\" (0x9F) maps terminated by \"break\" (0xBF) byte strings terminated by \"break\" (0x5F) date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) tagged items (0xC6..0xD4, 0xD8..0xDB) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) half-precision floats (0xF9) break (0xFF) Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00","title":"Serialization"},{"location":"features/binary_formats/cbor/#deserialization","text":"The library maps CBOR types to JSON value types as follows: CBOR type JSON value type first byte Integer number_unsigned 0x00..0x17 Unsigned integer number_unsigned 0x18 Unsigned integer number_unsigned 0x19 Unsigned integer number_unsigned 0x1A Unsigned integer number_unsigned 0x1B Negative integer number_integer 0x20..0x37 Negative integer number_integer 0x38 Negative integer number_integer 0x39 Negative integer number_integer 0x3A Negative integer number_integer 0x3B Byte string binary 0x40..0x57 Byte string binary 0x58 Byte string binary 0x59 Byte string binary 0x5A Byte string binary 0x5B UTF-8 string string 0x60..0x77 UTF-8 string string 0x78 UTF-8 string string 0x79 UTF-8 string string 0x7A UTF-8 string string 0x7B UTF-8 string string 0x7F array array 0x80..0x97 array array 0x98 array array 0x99 array array 0x9A array array 0x9B array array 0x9F map object 0xA0..0xB7 map object 0xB8 map object 0xB9 map object 0xBA map object 0xBB map object 0xBF False false 0xF4 True true 0xF5 Null null 0xF6 Half-Precision Float number_float 0xF9 Single-Precision Float number_float 0xFA Double-Precision Float number_float 0xFB Incomplete mapping The mapping is incomplete in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors: date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) tagged items (0xC6..0xD4, 0xD8..0xDB) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) Object keys CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/messagepack/","text":"MessagePack \u00b6 MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves. References MessagePack website MessagePack specification Serialization \u00b6 The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification: JSON value type value/range MessagePack type first byte null null nil 0xC0 boolean true true 0xC3 boolean false false 0xC2 number_integer -9223372036854775808..-2147483649 int64 0xD3 number_integer -2147483648..-32769 int32 0xD2 number_integer -32768..-129 int16 0xD1 number_integer -128..-33 int8 0xD0 number_integer -32..-1 negative fixint 0xE0..0xFF number_integer 0..127 positive fixint 0x00..0x7F number_integer 128..255 uint 8 0xCC number_integer 256..65535 uint 16 0xCD number_integer 65536..4294967295 uint 32 0xCE number_integer 4294967296..18446744073709551615 uint 64 0xCF number_unsigned 0..127 positive fixint 0x00..0x7F number_unsigned 128..255 uint 8 0xCC number_unsigned 256..65535 uint 16 0xCD number_unsigned 65536..4294967295 uint 32 0xCE number_unsigned 4294967296..18446744073709551615 uint 64 0xCF number_float any value float 64 0xCB string length : 0..31 fixstr 0xA0..0xBF string length : 32..255 str 8 0xD9 string length : 256..65535 str 16 0xDA string length : 65536..4294967295 str 32 0xDB array size : 0..15 fixarray 0x90..0x9F array size : 16..65535 array 16 0xDC array size : 65536..4294967295 array 32 0xDD object size : 0..15 fix map 0x80..0x8F object size : 16..65535 map 16 0xDE object size : 65536..4294967295 map 32 0xDF binary size : 0..255 bin 8 0xC4 binary size : 256..65535 bin 16 0xC5 binary size : 65536..4294967295 bin 32 0xC6 Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a MessagePack value. Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Size constraints The following values can not be converted to a MessagePack value: strings with more than 4294967295 bytes byte strings with more than 4294967295 bytes arrays with more than 4294967295 elements objects with more than 4294967295 elements Unused MessagePack types The following MessagePack types are not used in the conversion: float 32 (0xCA) NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. function which serializes NaN or Infinity to null . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 Deserialization \u00b6 The library maps MessagePack types to JSON value types as follows: MessagePack type JSON value type first byte positive fixint number_unsigned 0x00..0x7F fixmap object 0x80..0x8F fixarray array 0x90..0x9F fixstr string 0xA0..0xBF nil null 0xC0 false false 0xC2 true true 0xC3 float 32 number_float 0xCA float 64 number_float 0xCB uint 8 number_unsigned 0xCC uint 16 number_unsigned 0xCD uint 32 number_unsigned 0xCE uint 64 number_unsigned 0xCF int 8 number_integer 0xD0 int 16 number_integer 0xD1 int 32 number_integer 0xD2 int 64 number_integer 0xD3 str 8 string 0xD9 str 16 string 0xDA str 32 string 0xDB array 16 array 0xDC array 32 array 0xDD map 16 object 0xDE map 32 object 0xDF bin 8 binary 0xC4 bin 16 binary 0xC5 bin 32 binary 0xC6 ext 8 binary 0xC7 ext 16 binary 0xC8 ext 32 binary 0xC9 fixext 1 binary 0xD4 fixext 2 binary 0xD5 fixext 4 binary 0xD6 fixext 8 binary 0xD7 fixext 16 binary 0xD8 negative fixint number_integer 0xE0-0xFF Info Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"MessagePack"},{"location":"features/binary_formats/messagepack/#messagepack","text":"MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves. References MessagePack website MessagePack specification","title":"MessagePack"},{"location":"features/binary_formats/messagepack/#serialization","text":"The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification: JSON value type value/range MessagePack type first byte null null nil 0xC0 boolean true true 0xC3 boolean false false 0xC2 number_integer -9223372036854775808..-2147483649 int64 0xD3 number_integer -2147483648..-32769 int32 0xD2 number_integer -32768..-129 int16 0xD1 number_integer -128..-33 int8 0xD0 number_integer -32..-1 negative fixint 0xE0..0xFF number_integer 0..127 positive fixint 0x00..0x7F number_integer 128..255 uint 8 0xCC number_integer 256..65535 uint 16 0xCD number_integer 65536..4294967295 uint 32 0xCE number_integer 4294967296..18446744073709551615 uint 64 0xCF number_unsigned 0..127 positive fixint 0x00..0x7F number_unsigned 128..255 uint 8 0xCC number_unsigned 256..65535 uint 16 0xCD number_unsigned 65536..4294967295 uint 32 0xCE number_unsigned 4294967296..18446744073709551615 uint 64 0xCF number_float any value float 64 0xCB string length : 0..31 fixstr 0xA0..0xBF string length : 32..255 str 8 0xD9 string length : 256..65535 str 16 0xDA string length : 65536..4294967295 str 32 0xDB array size : 0..15 fixarray 0x90..0x9F array size : 16..65535 array 16 0xDC array size : 65536..4294967295 array 32 0xDD object size : 0..15 fix map 0x80..0x8F object size : 16..65535 map 16 0xDE object size : 65536..4294967295 map 32 0xDF binary size : 0..255 bin 8 0xC4 binary size : 256..65535 bin 16 0xC5 binary size : 65536..4294967295 bin 32 0xC6 Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a MessagePack value. Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Size constraints The following values can not be converted to a MessagePack value: strings with more than 4294967295 bytes byte strings with more than 4294967295 bytes arrays with more than 4294967295 elements objects with more than 4294967295 elements Unused MessagePack types The following MessagePack types are not used in the conversion: float 32 (0xCA) NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. function which serializes NaN or Infinity to null . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00","title":"Serialization"},{"location":"features/binary_formats/messagepack/#deserialization","text":"The library maps MessagePack types to JSON value types as follows: MessagePack type JSON value type first byte positive fixint number_unsigned 0x00..0x7F fixmap object 0x80..0x8F fixarray array 0x90..0x9F fixstr string 0xA0..0xBF nil null 0xC0 false false 0xC2 true true 0xC3 float 32 number_float 0xCA float 64 number_float 0xCB uint 8 number_unsigned 0xCC uint 16 number_unsigned 0xCD uint 32 number_unsigned 0xCE uint 64 number_unsigned 0xCF int 8 number_integer 0xD0 int 16 number_integer 0xD1 int 32 number_integer 0xD2 int 64 number_integer 0xD3 str 8 string 0xD9 str 16 string 0xDA str 32 string 0xDB array 16 array 0xDC array 32 array 0xDD map 16 object 0xDE map 32 object 0xDF bin 8 binary 0xC4 bin 16 binary 0xC5 bin 32 binary 0xC6 ext 8 binary 0xC7 ext 16 binary 0xC8 ext 32 binary 0xC9 fixext 1 binary 0xD4 fixext 2 binary 0xD5 fixext 4 binary 0xD6 fixext 8 binary 0xD7 fixext 16 binary 0xD8 negative fixint number_integer 0xE0-0xFF Info Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/ubjson/","text":"UBJSON \u00b6 Universal Binary JSON (UBJSON) is a binary form directly imitating JSON, but requiring fewer bytes of data. It aims to achieve the generality of JSON, combined with being much easier to process than JSON. References UBJSON Website Serialization \u00b6 The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification: JSON value type value/range UBJSON type marker null null null Z boolean true true T boolean false false F number_integer -9223372036854775808..-2147483649 int64 L number_integer -2147483648..-32769 int32 l number_integer -32768..-129 int16 I number_integer -128..127 int8 i number_integer 128..255 uint8 U number_integer 256..32767 int16 I number_integer 32768..2147483647 int32 l number_integer 2147483648..9223372036854775807 int64 L number_unsigned 0..127 int8 i number_unsigned 128..255 uint8 U number_unsigned 256..32767 int16 I number_unsigned 32768..2147483647 int32 l number_unsigned 2147483648..9223372036854775807 int64 L number_float any value float64 D string with shortest length indicator string S array see notes on optimized format array [ object see notes on optimized format map { Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a UBJSON value. Any UBJSON output created by to_ubjson can be successfully parsed by from_ubjson . Size constraints The following values can not be converted to a UBJSON value: strings with more than 9223372036854775807 bytes (theoretical) unsigned integer numbers above 9223372036854775807 Unused UBJSON markers The following markers are not used in the conversion: Z : no-op values are not created. C : single-byte strings are serialized with S markers. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null . Optimized formats The optimized formats for containers are supported: Parameter use_size adds size information to the beginning of a container and removes the closing marker. Parameter use_type further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The use_type parameter must only be used together with use_size = true . Note that use_size = true alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container. Binary values If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation. In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i1i2i3i4i5i6i7i8 ] [ # i8i1i2i3i4i5i6i7i8 [ $ i # i812345678 Deserialization \u00b6 The library maps UBJSON types to JSON value types as follows: UBJSON type JSON value type marker no-op no value, next value is read N null null Z false false F true true T float32 number_float d float64 number_float D uint8 number_unsigned U int8 number_integer i int16 number_integer I int32 number_integer l int64 number_integer L string string S char string C array array (optimized values are supported) [ object object (optimized values are supported) { Complete mapping The mapping is complete in the sense that any UBJSON value can be converted to a JSON value. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"UBJSON"},{"location":"features/binary_formats/ubjson/#ubjson","text":"Universal Binary JSON (UBJSON) is a binary form directly imitating JSON, but requiring fewer bytes of data. It aims to achieve the generality of JSON, combined with being much easier to process than JSON. References UBJSON Website","title":"UBJSON"},{"location":"features/binary_formats/ubjson/#serialization","text":"The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification: JSON value type value/range UBJSON type marker null null null Z boolean true true T boolean false false F number_integer -9223372036854775808..-2147483649 int64 L number_integer -2147483648..-32769 int32 l number_integer -32768..-129 int16 I number_integer -128..127 int8 i number_integer 128..255 uint8 U number_integer 256..32767 int16 I number_integer 32768..2147483647 int32 l number_integer 2147483648..9223372036854775807 int64 L number_unsigned 0..127 int8 i number_unsigned 128..255 uint8 U number_unsigned 256..32767 int16 I number_unsigned 32768..2147483647 int32 l number_unsigned 2147483648..9223372036854775807 int64 L number_float any value float64 D string with shortest length indicator string S array see notes on optimized format array [ object see notes on optimized format map { Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a UBJSON value. Any UBJSON output created by to_ubjson can be successfully parsed by from_ubjson . Size constraints The following values can not be converted to a UBJSON value: strings with more than 9223372036854775807 bytes (theoretical) unsigned integer numbers above 9223372036854775807 Unused UBJSON markers The following markers are not used in the conversion: Z : no-op values are not created. C : single-byte strings are serialized with S markers. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null . Optimized formats The optimized formats for containers are supported: Parameter use_size adds size information to the beginning of a container and removes the closing marker. Parameter use_type further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The use_type parameter must only be used together with use_size = true . Note that use_size = true alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container. Binary values If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation. In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i1i2i3i4i5i6i7i8 ] [ # i8i1i2i3i4i5i6i7i8 [ $ i # i812345678","title":"Serialization"},{"location":"features/binary_formats/ubjson/#deserialization","text":"The library maps UBJSON types to JSON value types as follows: UBJSON type JSON value type marker no-op no value, next value is read N null null Z false false F true true T float32 number_float d float64 number_float D uint8 number_unsigned U int8 number_integer i int16 number_integer I int32 number_integer l int64 number_integer L string string S char string C array array (optimized values are supported) [ object object (optimized values are supported) { Complete mapping The mapping is complete in the sense that any UBJSON value can be converted to a JSON value. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"home/code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mail@nlohmann.me . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"home/code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"home/code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"home/code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"home/code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"home/code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"home/code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mail@nlohmann.me . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"home/code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"home/design_goals/","text":"Design goals \u00b6 There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: Intuitive syntax . In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you'll know what I mean. Trivial integration . Our whole code consists of a single header file json.hpp . That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. Serious testing . Our class is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices . Other aspects were not so important to us: Memory efficiency . Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: std::string for strings, int64_t , uint64_t or double for numbers, std::map for objects, std::vector for arrays, and bool for Booleans. However, you can template the generalized class basic_json to your needs. Speed . There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a std::vector or std::map , you are already set. See the contribution guidelines for more information.","title":"Design goals"},{"location":"home/design_goals/#design-goals","text":"There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: Intuitive syntax . In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you'll know what I mean. Trivial integration . Our whole code consists of a single header file json.hpp . That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. Serious testing . Our class is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices . Other aspects were not so important to us: Memory efficiency . Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: std::string for strings, int64_t , uint64_t or double for numbers, std::map for objects, std::vector for arrays, and bool for Booleans. However, you can template the generalized class basic_json to your needs. Speed . There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a std::vector or std::map , you are already set. See the contribution guidelines for more information.","title":"Design goals"},{"location":"home/exceptions/","text":"Exceptions \u00b6 Overview \u00b6 Base type \u00b6 All exceptions inherit from class json::exception (which in turn inherits from std::exception ). It is used as the base class for all exceptions thrown by the basic_json class. This class can hence be used as \"wildcard\" to catch exceptions. Switch off exceptions \u00b6 Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag -fno-exceptions or by defining the symbol JSON_NOEXCEPTION . In this case, exceptions are replaced by abort() calls. You can further control this behavior by defining JSON_THROW_USER (overriding throw ), JSON_TRY_USER (overriding try ), and JSON_CATCH_USER (overriding catch ). Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. Parse errors \u00b6 This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch. Exceptions have ids 1xx. Byte index Member byte holds the byte index of the last read character in the input file. For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack). json.exception.parse_error.101 \u00b6 This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member byte indicates the error position. Example Input ended prematurely: [json.exception.parse_error.101] parse error at 2: unexpected end of input; expected string literal No input: [json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of input; expected '[', '{', or a literal Control character was not escaped: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\\\; last read: '\"<U+0009>'\" String was not closed: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: '\"' Invalid number format: [json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected '+', '-', or digit after exponent; last read: '1E' \\u was not be followed by four hex digits: [json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: '\\u' must be followed by 4 hex digits; last read: '\"\\u01\"' Invalid UTF-8 surrogate pair: [json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF; last read: '\"\\uD7FF\\uDC00'\" Invalid UTF-8 byte: [json.exception.parse_error.101] parse error at line 3, column 24: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"vous \\352t' Tip Make sure the input is correctly read. Try to write the input to standard output to check if, for instance, the input file was successfully openened. Paste the input to a JSON validator like http://jsonlint.com or a tool like jq . json.exception.parse_error.102 \u00b6 JSON uses the \\uxxxx format to describe Unicode characters. Code points above above 0xFFFF are split into two \\uxxxx entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point. Example parse error at 14: missing or wrong low surrogate json.exception.parse_error.103 \u00b6 Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid. Example parse error: code points above 0x10FFFF are invalid json.exception.parse_error.104 \u00b6 RFC 6902 requires a JSON Patch document to be a JSON document that represents an array of objects. Example [json.exception.parse_error.104] parse error: JSON patch must be an array of objects json.exception.parse_error.105 \u00b6 An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors. Example [json.exception.parse_error.105] parse error: operation 'add' must have member 'value' [json.exception.parse_error.105] parse error: operation 'copy' must have string member 'from' [json.exception.parse_error.105] parse error: operation value 'foo' is invalid json.exception.parse_error.106 \u00b6 An array index in a JSON Pointer ( RFC 6901 ) may be 0 or any number without a leading 0 . Example [json.exception.parse_error.106] parse error: array index '01' must not begin with '0' json.exception.parse_error.107 \u00b6 A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a / character. Example [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo' json.exception.parse_error.108 \u00b6 In a JSON Pointer, only ~0 and ~1 are valid escape sequences. Example [json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1' json.exception.parse_error.109 \u00b6 A JSON Pointer array index must be a number. Example [json.exception.parse_error.109] parse error: array index 'one' is not a number [json.exception.parse_error.109] parse error: array index '+1' is not a number json.exception.parse_error.110 \u00b6 When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read. Example [json.exception.parse_error.110] parse error at byte 5: syntax error while parsing CBOR string: unexpected end of input [json.exception.parse_error.110] parse error at byte 2: syntax error while parsing UBJSON value: expected end of input; last byte: 0x5A json.exception.parse_error.112 \u00b6 Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read. Example [json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0x1C json.exception.parse_error.113 \u00b6 While parsing a map key, a value that is not a string has been read. Example [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing CBOR string: expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing MessagePack string: expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing UBJSON char: byte after 'C' must be in range 0x00..0x7F; last byte: 0x82 json.exception.parse_error.114 \u00b6 The parsing of the corresponding BSON record type is not implemented (yet). Example [json.exception.parse_error.114] parse error at byte 5: Unsupported BSON record type 0xFF Iterator errors \u00b6 This exception is thrown if iterators passed to a library function do not match the expected semantics. Exceptions have ids 2xx. json.exception.invalid_iterator.201 \u00b6 The iterators passed to constructor basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example [json.exception.invalid_iterator.201] iterators are not compatible json.exception.invalid_iterator.202 \u00b6 In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion. Example [json.exception.invalid_iterator.202] iterator does not fit current value [json.exception.invalid_iterator.202] iterators first and last must point to objects json.exception.invalid_iterator.203 \u00b6 Either iterator passed to function erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from. Example [json.exception.invalid_iterator.203] iterators do not fit current value json.exception.invalid_iterator.204 \u00b6 When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly ( begin(), end()), because this is the only way the single stored value is expressed. All other ranges are invalid. Example [json.exception.invalid_iterator.204] iterators out of range json.exception.invalid_iterator.205 \u00b6 When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the begin() iterator, because it is the only way to address the stored value. All other iterators are invalid. Example [json.exception.invalid_iterator.205] iterator out of range json.exception.invalid_iterator.206 \u00b6 The iterators passed to constructor basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range. Example [json.exception.invalid_iterator.206] cannot construct with iterators from null json.exception.invalid_iterator.207 \u00b6 The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key. Example [json.exception.invalid_iterator.207] cannot use key() for non-object iterators json.exception.invalid_iterator.208 \u00b6 The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example [json.exception.invalid_iterator.208] cannot use operator[] for object iterators json.exception.invalid_iterator.209 \u00b6 The offset operators ( + , - , += , -= ) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example [json.exception.invalid_iterator.209] cannot use offsets with object iterators json.exception.invalid_iterator.210 \u00b6 The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example [json.exception.invalid_iterator.210] iterators do not fit json.exception.invalid_iterator.211 \u00b6 The iterator range passed to the insert function must not be a subrange of the container to insert to. Example [json.exception.invalid_iterator.211] passed iterators may not belong to container json.exception.invalid_iterator.212 \u00b6 When two iterators are compared, they must belong to the same container. Example [json.exception.invalid_iterator.212] cannot compare iterators of different containers json.exception.invalid_iterator.213 \u00b6 The order of object iterators cannot be compared, because JSON objects are unordered. Example [json.exception.invalid_iterator.213] cannot compare order of object iterators json.exception.invalid_iterator.214 \u00b6 Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to begin() . Example [json.exception.invalid_iterator.214] cannot get value Type errors \u00b6 This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics. Exceptions have ids 3xx. json.exception.type_error.301 \u00b6 To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead. Example [json.exception.type_error.301] cannot create object from initializer list json.exception.type_error.302 \u00b6 During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types. Example [json.exception.type_error.302] type must be object, but is null [json.exception.type_error.302] type must be string, but is object json.exception.type_error.303 \u00b6 To retrieve a reference to a value stored in a basic_json object with get_ref , the type of the reference must match the value type. For instance, for a JSON array, the ReferenceType must be array_t & . Example [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is object [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\" json.exception.type_error.304 \u00b6 The at() member functions can only be executed for certain JSON types. Example [json.exception.type_error.304] cannot use at() with string [json.exception.type_error.304] cannot use at() with number json.exception.type_error.305 \u00b6 The operator[] member functions can only be executed for certain JSON types. Example [json.exception.type_error.305] cannot use operator[] with a string argument with array [json.exception.type_error.305] cannot use operator[] with a numeric argument with object json.exception.type_error.306 \u00b6 The value() member functions can only be executed for certain JSON types. Example [json.exception.type_error.306] cannot use value() with number json.exception.type_error.307 \u00b6 The erase() member functions can only be executed for certain JSON types. Example [json.exception.type_error.307] cannot use erase() with string json.exception.type_error.308 \u00b6 The push_back() and operator+= member functions can only be executed for certain JSON types. Example [json.exception.type_error.308] cannot use push_back() with string json.exception.type_error.309 \u00b6 The insert() member functions can only be executed for certain JSON types. Example [json.exception.type_error.309] cannot use insert() with array [json.exception.type_error.309] cannot use insert() with number json.exception.type_error.310 \u00b6 The swap() member functions can only be executed for certain JSON types. Example [json.exception.type_error.310] cannot use swap() with number json.exception.type_error.311 \u00b6 The emplace() and emplace_back() member functions can only be executed for certain JSON types. Example [json.exception.type_error.311] cannot use emplace() with number [json.exception.type_error.311] cannot use emplace_back() with number json.exception.type_error.312 \u00b6 The update() member functions can only be executed for certain JSON types. Example [json.exception.type_error.312] cannot use update() with array json.exception.type_error.313 \u00b6 The unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined. Example [json.exception.type_error.313] invalid value to unflatten json.exception.type_error.314 \u00b6 The unflatten function only works for an object whose keys are JSON Pointers. Example Calling unflatten() on an array [ 1 , 2 , 3 ] : [json.exception.type_error.314] only objects can be unflattened json.exception.type_error.315 \u00b6 The unflatten() function only works for an object whose keys are JSON Pointers and whose values are primitive. Example Calling unflatten() on an object { \"/1\" , [1,2,3] } : [json.exception.type_error.315] values in object must be primitive json.exception.type_error.316 \u00b6 The dump() function only works with UTF-8 encoded strings; that is, if you assign a std::string to a JSON value, make sure it is UTF-8 encoded. Example Calling dump() on a JSON value containing an ISO 8859-1 encoded string: [json.exception.type_error.316] invalid UTF-8 byte at index 15: 0x6F Tip Store the source file with UTF-8 encoding. Pass an error handler as last parameter to the dump() function to avoid this exception: json::error_handler_t::replace will replace invalid bytes sequences with U+FFFD json::error_handler_t::ignore will silently ignore invalid byte sequences json.exception.type_error.317 \u00b6 The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw true or null JSON object cannot be serialized to BSON) Example Serializing null to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is null Serializing [ 1 , 2 , 3 ] to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is array Tip Encapsulate the JSON value in an object. That is, instead of serializing true , serialize { \"value\" : true } Out of range \u00b6 This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys. Exceptions have ids 4xx. json.exception.out_of_range.401 \u00b6 The provided array index i is larger than size-1 . Example array index 3 is out of range json.exception.out_of_range.402 \u00b6 The special array index - in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it. Example array index '-' (3) is out of range json.exception.out_of_range.403 \u00b6 The provided key was not found in the JSON object. Example key 'foo' not found json.exception.out_of_range.404 \u00b6 A reference token in a JSON Pointer could not be resolved. Example unresolved reference token 'foo' json.exception.out_of_range.405 \u00b6 The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value. Example JSON pointer has no parent json.exception.out_of_range.406 \u00b6 A parsed number could not be stored as without changing it to NaN or INF. Example number overflow parsing '10E1000' json.exception.out_of_range.407 \u00b6 UBJSON and BSON only support integer numbers up to 9223372036854775807. Example number overflow serializing '9223372036854775808' json.exception.out_of_range.408 \u00b6 The size (following # ) of an UBJSON array or object exceeds the maximal capacity. Example excessive array size: 8658170730974374167 json.exception.out_of_range.409 \u00b6 Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string. Example BSON key cannot contain code point U+0000 (at byte 2) Further exceptions \u00b6 This exception is thrown in case of errors that cannot be classified with the other exception types. Exceptions have ids 5xx. json.exception.other_error.501 \u00b6 A JSON Patch operation 'test' failed. The unsuccessful operation is also printed. Example Executing { \"op\" : \"test\" , \"path\" : \"/baz\" , \"value\" : \"bar\" } on { \"baz\" : \"qux\" } : [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/baz\",\"value\":\"bar\"}","title":"Exceptions"},{"location":"home/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"home/exceptions/#overview","text":"","title":"Overview"},{"location":"home/exceptions/#base-type","text":"All exceptions inherit from class json::exception (which in turn inherits from std::exception ). It is used as the base class for all exceptions thrown by the basic_json class. This class can hence be used as \"wildcard\" to catch exceptions.","title":"Base type"},{"location":"home/exceptions/#switch-off-exceptions","text":"Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag -fno-exceptions or by defining the symbol JSON_NOEXCEPTION . In this case, exceptions are replaced by abort() calls. You can further control this behavior by defining JSON_THROW_USER (overriding throw ), JSON_TRY_USER (overriding try ), and JSON_CATCH_USER (overriding catch ). Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior.","title":"Switch off exceptions"},{"location":"home/exceptions/#parse-errors","text":"This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch. Exceptions have ids 1xx. Byte index Member byte holds the byte index of the last read character in the input file. For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack).","title":"Parse errors"},{"location":"home/exceptions/#jsonexceptionparse_error101","text":"This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member byte indicates the error position. Example Input ended prematurely: [json.exception.parse_error.101] parse error at 2: unexpected end of input; expected string literal No input: [json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of input; expected '[', '{', or a literal Control character was not escaped: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\\\; last read: '\"<U+0009>'\" String was not closed: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: '\"' Invalid number format: [json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected '+', '-', or digit after exponent; last read: '1E' \\u was not be followed by four hex digits: [json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: '\\u' must be followed by 4 hex digits; last read: '\"\\u01\"' Invalid UTF-8 surrogate pair: [json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF; last read: '\"\\uD7FF\\uDC00'\" Invalid UTF-8 byte: [json.exception.parse_error.101] parse error at line 3, column 24: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"vous \\352t' Tip Make sure the input is correctly read. Try to write the input to standard output to check if, for instance, the input file was successfully openened. Paste the input to a JSON validator like http://jsonlint.com or a tool like jq .","title":"json.exception.parse_error.101"},{"location":"home/exceptions/#jsonexceptionparse_error102","text":"JSON uses the \\uxxxx format to describe Unicode characters. Code points above above 0xFFFF are split into two \\uxxxx entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point. Example parse error at 14: missing or wrong low surrogate","title":"json.exception.parse_error.102"},{"location":"home/exceptions/#jsonexceptionparse_error103","text":"Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid. Example parse error: code points above 0x10FFFF are invalid","title":"json.exception.parse_error.103"},{"location":"home/exceptions/#jsonexceptionparse_error104","text":"RFC 6902 requires a JSON Patch document to be a JSON document that represents an array of objects. Example [json.exception.parse_error.104] parse error: JSON patch must be an array of objects","title":"json.exception.parse_error.104"},{"location":"home/exceptions/#jsonexceptionparse_error105","text":"An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors. Example [json.exception.parse_error.105] parse error: operation 'add' must have member 'value' [json.exception.parse_error.105] parse error: operation 'copy' must have string member 'from' [json.exception.parse_error.105] parse error: operation value 'foo' is invalid","title":"json.exception.parse_error.105"},{"location":"home/exceptions/#jsonexceptionparse_error106","text":"An array index in a JSON Pointer ( RFC 6901 ) may be 0 or any number without a leading 0 . Example [json.exception.parse_error.106] parse error: array index '01' must not begin with '0'","title":"json.exception.parse_error.106"},{"location":"home/exceptions/#jsonexceptionparse_error107","text":"A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a / character. Example [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo'","title":"json.exception.parse_error.107"},{"location":"home/exceptions/#jsonexceptionparse_error108","text":"In a JSON Pointer, only ~0 and ~1 are valid escape sequences. Example [json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1'","title":"json.exception.parse_error.108"},{"location":"home/exceptions/#jsonexceptionparse_error109","text":"A JSON Pointer array index must be a number. Example [json.exception.parse_error.109] parse error: array index 'one' is not a number [json.exception.parse_error.109] parse error: array index '+1' is not a number","title":"json.exception.parse_error.109"},{"location":"home/exceptions/#jsonexceptionparse_error110","text":"When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read. Example [json.exception.parse_error.110] parse error at byte 5: syntax error while parsing CBOR string: unexpected end of input [json.exception.parse_error.110] parse error at byte 2: syntax error while parsing UBJSON value: expected end of input; last byte: 0x5A","title":"json.exception.parse_error.110"},{"location":"home/exceptions/#jsonexceptionparse_error112","text":"Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read. Example [json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0x1C","title":"json.exception.parse_error.112"},{"location":"home/exceptions/#jsonexceptionparse_error113","text":"While parsing a map key, a value that is not a string has been read. Example [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing CBOR string: expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing MessagePack string: expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing UBJSON char: byte after 'C' must be in range 0x00..0x7F; last byte: 0x82","title":"json.exception.parse_error.113"},{"location":"home/exceptions/#jsonexceptionparse_error114","text":"The parsing of the corresponding BSON record type is not implemented (yet). Example [json.exception.parse_error.114] parse error at byte 5: Unsupported BSON record type 0xFF","title":"json.exception.parse_error.114"},{"location":"home/exceptions/#iterator-errors","text":"This exception is thrown if iterators passed to a library function do not match the expected semantics. Exceptions have ids 2xx.","title":"Iterator errors"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator201","text":"The iterators passed to constructor basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example [json.exception.invalid_iterator.201] iterators are not compatible","title":"json.exception.invalid_iterator.201"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator202","text":"In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion. Example [json.exception.invalid_iterator.202] iterator does not fit current value [json.exception.invalid_iterator.202] iterators first and last must point to objects","title":"json.exception.invalid_iterator.202"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator203","text":"Either iterator passed to function erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from. Example [json.exception.invalid_iterator.203] iterators do not fit current value","title":"json.exception.invalid_iterator.203"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator204","text":"When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly ( begin(), end()), because this is the only way the single stored value is expressed. All other ranges are invalid. Example [json.exception.invalid_iterator.204] iterators out of range","title":"json.exception.invalid_iterator.204"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator205","text":"When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the begin() iterator, because it is the only way to address the stored value. All other iterators are invalid. Example [json.exception.invalid_iterator.205] iterator out of range","title":"json.exception.invalid_iterator.205"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator206","text":"The iterators passed to constructor basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range. Example [json.exception.invalid_iterator.206] cannot construct with iterators from null","title":"json.exception.invalid_iterator.206"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator207","text":"The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key. Example [json.exception.invalid_iterator.207] cannot use key() for non-object iterators","title":"json.exception.invalid_iterator.207"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator208","text":"The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example [json.exception.invalid_iterator.208] cannot use operator[] for object iterators","title":"json.exception.invalid_iterator.208"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator209","text":"The offset operators ( + , - , += , -= ) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example [json.exception.invalid_iterator.209] cannot use offsets with object iterators","title":"json.exception.invalid_iterator.209"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator210","text":"The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example [json.exception.invalid_iterator.210] iterators do not fit","title":"json.exception.invalid_iterator.210"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator211","text":"The iterator range passed to the insert function must not be a subrange of the container to insert to. Example [json.exception.invalid_iterator.211] passed iterators may not belong to container","title":"json.exception.invalid_iterator.211"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator212","text":"When two iterators are compared, they must belong to the same container. Example [json.exception.invalid_iterator.212] cannot compare iterators of different containers","title":"json.exception.invalid_iterator.212"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator213","text":"The order of object iterators cannot be compared, because JSON objects are unordered. Example [json.exception.invalid_iterator.213] cannot compare order of object iterators","title":"json.exception.invalid_iterator.213"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator214","text":"Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to begin() . Example [json.exception.invalid_iterator.214] cannot get value","title":"json.exception.invalid_iterator.214"},{"location":"home/exceptions/#type-errors","text":"This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics. Exceptions have ids 3xx.","title":"Type errors"},{"location":"home/exceptions/#jsonexceptiontype_error301","text":"To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead. Example [json.exception.type_error.301] cannot create object from initializer list","title":"json.exception.type_error.301"},{"location":"home/exceptions/#jsonexceptiontype_error302","text":"During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types. Example [json.exception.type_error.302] type must be object, but is null [json.exception.type_error.302] type must be string, but is object","title":"json.exception.type_error.302"},{"location":"home/exceptions/#jsonexceptiontype_error303","text":"To retrieve a reference to a value stored in a basic_json object with get_ref , the type of the reference must match the value type. For instance, for a JSON array, the ReferenceType must be array_t & . Example [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is object [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\"","title":"json.exception.type_error.303"},{"location":"home/exceptions/#jsonexceptiontype_error304","text":"The at() member functions can only be executed for certain JSON types. Example [json.exception.type_error.304] cannot use at() with string [json.exception.type_error.304] cannot use at() with number","title":"json.exception.type_error.304"},{"location":"home/exceptions/#jsonexceptiontype_error305","text":"The operator[] member functions can only be executed for certain JSON types. Example [json.exception.type_error.305] cannot use operator[] with a string argument with array [json.exception.type_error.305] cannot use operator[] with a numeric argument with object","title":"json.exception.type_error.305"},{"location":"home/exceptions/#jsonexceptiontype_error306","text":"The value() member functions can only be executed for certain JSON types. Example [json.exception.type_error.306] cannot use value() with number","title":"json.exception.type_error.306"},{"location":"home/exceptions/#jsonexceptiontype_error307","text":"The erase() member functions can only be executed for certain JSON types. Example [json.exception.type_error.307] cannot use erase() with string","title":"json.exception.type_error.307"},{"location":"home/exceptions/#jsonexceptiontype_error308","text":"The push_back() and operator+= member functions can only be executed for certain JSON types. Example [json.exception.type_error.308] cannot use push_back() with string","title":"json.exception.type_error.308"},{"location":"home/exceptions/#jsonexceptiontype_error309","text":"The insert() member functions can only be executed for certain JSON types. Example [json.exception.type_error.309] cannot use insert() with array [json.exception.type_error.309] cannot use insert() with number","title":"json.exception.type_error.309"},{"location":"home/exceptions/#jsonexceptiontype_error310","text":"The swap() member functions can only be executed for certain JSON types. Example [json.exception.type_error.310] cannot use swap() with number","title":"json.exception.type_error.310"},{"location":"home/exceptions/#jsonexceptiontype_error311","text":"The emplace() and emplace_back() member functions can only be executed for certain JSON types. Example [json.exception.type_error.311] cannot use emplace() with number [json.exception.type_error.311] cannot use emplace_back() with number","title":"json.exception.type_error.311"},{"location":"home/exceptions/#jsonexceptiontype_error312","text":"The update() member functions can only be executed for certain JSON types. Example [json.exception.type_error.312] cannot use update() with array","title":"json.exception.type_error.312"},{"location":"home/exceptions/#jsonexceptiontype_error313","text":"The unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined. Example [json.exception.type_error.313] invalid value to unflatten","title":"json.exception.type_error.313"},{"location":"home/exceptions/#jsonexceptiontype_error314","text":"The unflatten function only works for an object whose keys are JSON Pointers. Example Calling unflatten() on an array [ 1 , 2 , 3 ] : [json.exception.type_error.314] only objects can be unflattened","title":"json.exception.type_error.314"},{"location":"home/exceptions/#jsonexceptiontype_error315","text":"The unflatten() function only works for an object whose keys are JSON Pointers and whose values are primitive. Example Calling unflatten() on an object { \"/1\" , [1,2,3] } : [json.exception.type_error.315] values in object must be primitive","title":"json.exception.type_error.315"},{"location":"home/exceptions/#jsonexceptiontype_error316","text":"The dump() function only works with UTF-8 encoded strings; that is, if you assign a std::string to a JSON value, make sure it is UTF-8 encoded. Example Calling dump() on a JSON value containing an ISO 8859-1 encoded string: [json.exception.type_error.316] invalid UTF-8 byte at index 15: 0x6F Tip Store the source file with UTF-8 encoding. Pass an error handler as last parameter to the dump() function to avoid this exception: json::error_handler_t::replace will replace invalid bytes sequences with U+FFFD json::error_handler_t::ignore will silently ignore invalid byte sequences","title":"json.exception.type_error.316"},{"location":"home/exceptions/#jsonexceptiontype_error317","text":"The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw true or null JSON object cannot be serialized to BSON) Example Serializing null to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is null Serializing [ 1 , 2 , 3 ] to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is array Tip Encapsulate the JSON value in an object. That is, instead of serializing true , serialize { \"value\" : true }","title":"json.exception.type_error.317"},{"location":"home/exceptions/#out-of-range","text":"This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys. Exceptions have ids 4xx.","title":"Out of range"},{"location":"home/exceptions/#jsonexceptionout_of_range401","text":"The provided array index i is larger than size-1 . Example array index 3 is out of range","title":"json.exception.out_of_range.401"},{"location":"home/exceptions/#jsonexceptionout_of_range402","text":"The special array index - in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it. Example array index '-' (3) is out of range","title":"json.exception.out_of_range.402"},{"location":"home/exceptions/#jsonexceptionout_of_range403","text":"The provided key was not found in the JSON object. Example key 'foo' not found","title":"json.exception.out_of_range.403"},{"location":"home/exceptions/#jsonexceptionout_of_range404","text":"A reference token in a JSON Pointer could not be resolved. Example unresolved reference token 'foo'","title":"json.exception.out_of_range.404"},{"location":"home/exceptions/#jsonexceptionout_of_range405","text":"The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value. Example JSON pointer has no parent","title":"json.exception.out_of_range.405"},{"location":"home/exceptions/#jsonexceptionout_of_range406","text":"A parsed number could not be stored as without changing it to NaN or INF. Example number overflow parsing '10E1000'","title":"json.exception.out_of_range.406"},{"location":"home/exceptions/#jsonexceptionout_of_range407","text":"UBJSON and BSON only support integer numbers up to 9223372036854775807. Example number overflow serializing '9223372036854775808'","title":"json.exception.out_of_range.407"},{"location":"home/exceptions/#jsonexceptionout_of_range408","text":"The size (following # ) of an UBJSON array or object exceeds the maximal capacity. Example excessive array size: 8658170730974374167","title":"json.exception.out_of_range.408"},{"location":"home/exceptions/#jsonexceptionout_of_range409","text":"Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string. Example BSON key cannot contain code point U+0000 (at byte 2)","title":"json.exception.out_of_range.409"},{"location":"home/exceptions/#further-exceptions","text":"This exception is thrown in case of errors that cannot be classified with the other exception types. Exceptions have ids 5xx.","title":"Further exceptions"},{"location":"home/exceptions/#jsonexceptionother_error501","text":"A JSON Patch operation 'test' failed. The unsuccessful operation is also printed. Example Executing { \"op\" : \"test\" , \"path\" : \"/baz\" , \"value\" : \"bar\" } on { \"baz\" : \"qux\" } : [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/baz\",\"value\":\"bar\"}","title":"json.exception.other_error.501"},{"location":"home/faq/","text":"Frequently Asked Questions (FAQ) \u00b6 Limitations \u00b6 Comments \u00b6 Questions Why does the library not support comments? Can you add support for JSON5/JSONC/HOCON so that comments are supported? This library does not support comments. It does so for three reasons: Comments are not part of the JSON specification . You may argue that // or /* */ are allowed in JavaScript, but JSON is not JavaScript. This was not an oversight: Douglas Crockford wrote on this in May 2012: I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't. Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check The Harmful Consequences of the Robustness Principle on this. This library will not support comments in the future. If you wish to use comments, I see three options: Strip comments before using this library. Use a different JSON library with comment support. Use a format that natively supports comments (e.g., YAML or JSON5). Relaxed parsing \u00b6 Question Can you add an option to ignore trailing commas? For the same reason this library does not support comments , this library also does not support any feature which would jeopardize interoperability. Parse errors reading non-ASCII characters \u00b6 Questions Why is the parser complaining about a Chinese character? Does the library support Unicode? I get an exception [json.exception.parse_error.101] parse error at line 1, column 53: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"Test\u00e9$')\" The library supports Unicode input as follows: Only UTF-8 encoded input is supported which is the default encoding for JSON according to RFC 8259 . std::u16string and std::u32string can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers. Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors. Unicode noncharacters will not be replaced by the library. Invalid surrogates (e.g., incomplete pairs such as \\uDEAD ) will yield parse errors. The strings stored in the library are UTF-8 encoded. When using the default string type ( std::string ), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs. When you store strings with different encodings in the library, calling dump() may throw an exception unless json::error_handler_t::replace or json::error_handler_t::ignore are used as error handlers. In most cases, the parser is right to complain, because the input is not UTF-8 encoded. This is especially true for Microsoft Windows where Latin-1 or ISO 8859-1 is often the standard encoding. Key name in exceptions \u00b6 Question Can I get the key of the object item that caused an exception? No, this is not possible. See https://github.com/nlohmann/json/issues/932 for a longer discussion. Serialization issues \u00b6 Order of object keys \u00b6 Questions Why are object keys sorted? Why is the insertion order of object keys not preserved? By default, the library does not preserve the insertion order of object elements . This is standards-compliant, as the JSON standard defines objects as \"an unordered collection of zero or more name/value pairs\". If you do want to preserve the insertion order, you can specialize the object type with containers like tsl::ordered_map ( integration ) or nlohmann::fifo_map ( integration ). Number precision \u00b6 Question It seems that precision is lost when serializing a double. Can I change the precision for floating-point serialization? The library uses std::numeric_limits<number_float_t>::digits10 (15 for IEEE double s) digits for serialization. This value is sufficient to guarantee roundtripping. If one uses more than this number of digits of precision, then string -> value -> string is not guaranteed to round-trip. cppreference.com The value of std::numeric_limits<T>::digits10 is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. Tip The website https://float.exposed gives a good insight into the internal storage of floating-point numbers. Compilation issues \u00b6 Android SDK \u00b6 Question Why does the code not compile with Android SDK? Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your Application.mk . This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default. APP_STL : = c++_shared NDK_TOOLCHAIN_VERSION : = clang3.6 APP_CPPFLAGS + = -frtti -fexceptions The code compiles successfully with Android NDK , Revision 9 - 11 (and possibly later) and CrystaX's Android NDK version 10. Missing STL function \u00b6 Questions Why do I get a compilation error 'to_string' is not a member of 'std' (or similarly, for strtod or strtof )? Why does the code not compile with MinGW or Android SDK? This is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment. For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using APP_STL := gnustl_static , please refer to this discussion .","title":"FAQ"},{"location":"home/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"home/faq/#limitations","text":"","title":"Limitations"},{"location":"home/faq/#comments","text":"Questions Why does the library not support comments? Can you add support for JSON5/JSONC/HOCON so that comments are supported? This library does not support comments. It does so for three reasons: Comments are not part of the JSON specification . You may argue that // or /* */ are allowed in JavaScript, but JSON is not JavaScript. This was not an oversight: Douglas Crockford wrote on this in May 2012: I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't. Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check The Harmful Consequences of the Robustness Principle on this. This library will not support comments in the future. If you wish to use comments, I see three options: Strip comments before using this library. Use a different JSON library with comment support. Use a format that natively supports comments (e.g., YAML or JSON5).","title":"Comments"},{"location":"home/faq/#relaxed-parsing","text":"Question Can you add an option to ignore trailing commas? For the same reason this library does not support comments , this library also does not support any feature which would jeopardize interoperability.","title":"Relaxed parsing"},{"location":"home/faq/#parse-errors-reading-non-ascii-characters","text":"Questions Why is the parser complaining about a Chinese character? Does the library support Unicode? I get an exception [json.exception.parse_error.101] parse error at line 1, column 53: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"Test\u00e9$')\" The library supports Unicode input as follows: Only UTF-8 encoded input is supported which is the default encoding for JSON according to RFC 8259 . std::u16string and std::u32string can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers. Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors. Unicode noncharacters will not be replaced by the library. Invalid surrogates (e.g., incomplete pairs such as \\uDEAD ) will yield parse errors. The strings stored in the library are UTF-8 encoded. When using the default string type ( std::string ), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs. When you store strings with different encodings in the library, calling dump() may throw an exception unless json::error_handler_t::replace or json::error_handler_t::ignore are used as error handlers. In most cases, the parser is right to complain, because the input is not UTF-8 encoded. This is especially true for Microsoft Windows where Latin-1 or ISO 8859-1 is often the standard encoding.","title":"Parse errors reading non-ASCII characters"},{"location":"home/faq/#key-name-in-exceptions","text":"Question Can I get the key of the object item that caused an exception? No, this is not possible. See https://github.com/nlohmann/json/issues/932 for a longer discussion.","title":"Key name in exceptions"},{"location":"home/faq/#serialization-issues","text":"","title":"Serialization issues"},{"location":"home/faq/#order-of-object-keys","text":"Questions Why are object keys sorted? Why is the insertion order of object keys not preserved? By default, the library does not preserve the insertion order of object elements . This is standards-compliant, as the JSON standard defines objects as \"an unordered collection of zero or more name/value pairs\". If you do want to preserve the insertion order, you can specialize the object type with containers like tsl::ordered_map ( integration ) or nlohmann::fifo_map ( integration ).","title":"Order of object keys"},{"location":"home/faq/#number-precision","text":"Question It seems that precision is lost when serializing a double. Can I change the precision for floating-point serialization? The library uses std::numeric_limits<number_float_t>::digits10 (15 for IEEE double s) digits for serialization. This value is sufficient to guarantee roundtripping. If one uses more than this number of digits of precision, then string -> value -> string is not guaranteed to round-trip. cppreference.com The value of std::numeric_limits<T>::digits10 is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. Tip The website https://float.exposed gives a good insight into the internal storage of floating-point numbers.","title":"Number precision"},{"location":"home/faq/#compilation-issues","text":"","title":"Compilation issues"},{"location":"home/faq/#android-sdk","text":"Question Why does the code not compile with Android SDK? Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your Application.mk . This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default. APP_STL : = c++_shared NDK_TOOLCHAIN_VERSION : = clang3.6 APP_CPPFLAGS + = -frtti -fexceptions The code compiles successfully with Android NDK , Revision 9 - 11 (and possibly later) and CrystaX's Android NDK version 10.","title":"Android SDK"},{"location":"home/faq/#missing-stl-function","text":"Questions Why do I get a compilation error 'to_string' is not a member of 'std' (or similarly, for strtod or strtof )? Why does the code not compile with MinGW or Android SDK? This is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment. For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using APP_STL := gnustl_static , please refer to this discussion .","title":"Missing STL function"},{"location":"home/license/","text":"License \u00b6 The class is licensed under the MIT License : Copyright \u00a9 2013-2019 Niels Lohmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License (see above). Copyright \u00a9 2008-2009 Bj\u00f6rn Hoehrmann bjoern@hoehrmann.de The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License (see above). Copyright \u00a9 2009 Florian Loitsch The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0 .","title":"License"},{"location":"home/license/#license","text":"The class is licensed under the MIT License : Copyright \u00a9 2013-2019 Niels Lohmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License (see above). Copyright \u00a9 2008-2009 Bj\u00f6rn Hoehrmann bjoern@hoehrmann.de The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License (see above). Copyright \u00a9 2009 Florian Loitsch The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0 .","title":"License"},{"location":"home/sponsors/","text":"Sponsors \u00b6 You can sponsor this library at GitHub Sponsors . Named Sponsors \u00b6 Michael Hartmann Stefan Hagen Steve Sperandeo Thanks everyone!","title":"Sponsors"},{"location":"home/sponsors/#sponsors","text":"You can sponsor this library at GitHub Sponsors .","title":"Sponsors"},{"location":"home/sponsors/#named-sponsors","text":"Michael Hartmann Stefan Hagen Steve Sperandeo Thanks everyone!","title":"Named Sponsors"},{"location":"integration/","text":"Integration \u00b6 json.hpp is the single required file in single_include/nlohmann or released here . You need to add #include <nlohmann/json.hpp> // for convenience using json = nlohmann :: json ; to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., -std=c++11 for GCC and Clang). You can further use file include/nlohmann/json_fwd.hpp for forward-declarations. The installation of json_fwd.hpp (as part of cmake's install step), can be achieved by setting -DJSON_MultipleHeaders=ON .","title":"Integration"},{"location":"integration/#integration","text":"json.hpp is the single required file in single_include/nlohmann or released here . You need to add #include <nlohmann/json.hpp> // for convenience using json = nlohmann :: json ; to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., -std=c++11 for GCC and Clang). You can further use file include/nlohmann/json_fwd.hpp for forward-declarations. The installation of json_fwd.hpp (as part of cmake's install step), can be achieved by setting -DJSON_MultipleHeaders=ON .","title":"Integration"},{"location":"integration/cmake/","text":"CMake \u00b6 You can also use the nlohmann_json::nlohmann_json interface target in CMake. This target populates the appropriate usage requirements for INTERFACE_INCLUDE_DIRECTORIES to point to the appropriate include directories and INTERFACE_COMPILE_FEATURES for the necessary C++11 flags. External \u00b6 To use this library from a CMake project, you can locate it directly with find_package() and use the namespaced imported target from the generated package configuration: # CMakeLists.txt find_package ( nlohmann_json 3.2.0 REQUIRED ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) The package configuration file, nlohmann_jsonConfig.cmake , can be used either from an install tree or directly out of the build tree. Embedded \u00b6 To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call add_subdirectory() in your CMakeLists.txt file: # Typically you don't care so much for a third party library's tests to be # run from your own project's code. set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) # If you only include this third party in PRIVATE source files, you do not # need to install it when your main project gets installed. # set(JSON_Install OFF CACHE INTERNAL \"\") # Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it # unintended consequences that will break the build. It's generally # discouraged (although not necessarily well documented as such) to use # include(...) for pulling in other CMake projects anyways. add_subdirectory ( nlohmann_json ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Embedded (FetchContent) \u00b6 Since CMake v3.11, FetchContent can be used to automatically download the repository as a dependency at configure type. Example: include ( FetchContent ) FetchContent_Declare ( json GIT_REPOSITORY https://github.com/nlohmann/json GIT_TAG v3.7.3 ) FetchContent_GetProperties ( json ) if ( NOT json_POPULATED ) FetchContent_Populate ( json ) add_subdirectory ( ${ json_SOURCE_DIR } ${ json_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Note The repository https://github.com/nlohmann/json download size is huge. It contains all the dataset used for the benchmarks. You might want to depend on a smaller repository. For instance, you might want to replace the URL above by https://github.com/ArthurSonzogni/nlohmann_json_cmake_fetchcontent . Supporting Both \u00b6 To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following: # Top level CMakeLists.txt project ( FOO ) ... option ( FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF ) ... add_subdirectory ( thirdparty ) ... add_library ( foo ... ) ... # Note that the namespaced target will always be available regardless of the # import method target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) # thirdparty/CMakeLists.txt ... if ( FOO_USE_EXTERNAL_JSON ) find_package ( nlohmann_json 3.2.0 REQUIRED ) else () set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) add_subdirectory ( nlohmann_json ) endif () ... thirdparty/nlohmann_json is then a complete copy of this source tree.","title":"CMake"},{"location":"integration/cmake/#cmake","text":"You can also use the nlohmann_json::nlohmann_json interface target in CMake. This target populates the appropriate usage requirements for INTERFACE_INCLUDE_DIRECTORIES to point to the appropriate include directories and INTERFACE_COMPILE_FEATURES for the necessary C++11 flags.","title":"CMake"},{"location":"integration/cmake/#external","text":"To use this library from a CMake project, you can locate it directly with find_package() and use the namespaced imported target from the generated package configuration: # CMakeLists.txt find_package ( nlohmann_json 3.2.0 REQUIRED ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) The package configuration file, nlohmann_jsonConfig.cmake , can be used either from an install tree or directly out of the build tree.","title":"External"},{"location":"integration/cmake/#embedded","text":"To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call add_subdirectory() in your CMakeLists.txt file: # Typically you don't care so much for a third party library's tests to be # run from your own project's code. set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) # If you only include this third party in PRIVATE source files, you do not # need to install it when your main project gets installed. # set(JSON_Install OFF CACHE INTERNAL \"\") # Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it # unintended consequences that will break the build. It's generally # discouraged (although not necessarily well documented as such) to use # include(...) for pulling in other CMake projects anyways. add_subdirectory ( nlohmann_json ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json )","title":"Embedded"},{"location":"integration/cmake/#embedded-fetchcontent","text":"Since CMake v3.11, FetchContent can be used to automatically download the repository as a dependency at configure type. Example: include ( FetchContent ) FetchContent_Declare ( json GIT_REPOSITORY https://github.com/nlohmann/json GIT_TAG v3.7.3 ) FetchContent_GetProperties ( json ) if ( NOT json_POPULATED ) FetchContent_Populate ( json ) add_subdirectory ( ${ json_SOURCE_DIR } ${ json_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Note The repository https://github.com/nlohmann/json download size is huge. It contains all the dataset used for the benchmarks. You might want to depend on a smaller repository. For instance, you might want to replace the URL above by https://github.com/ArthurSonzogni/nlohmann_json_cmake_fetchcontent .","title":"Embedded (FetchContent)"},{"location":"integration/cmake/#supporting-both","text":"To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following: # Top level CMakeLists.txt project ( FOO ) ... option ( FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF ) ... add_subdirectory ( thirdparty ) ... add_library ( foo ... ) ... # Note that the namespaced target will always be available regardless of the # import method target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) # thirdparty/CMakeLists.txt ... if ( FOO_USE_EXTERNAL_JSON ) find_package ( nlohmann_json 3.2.0 REQUIRED ) else () set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) add_subdirectory ( nlohmann_json ) endif () ... thirdparty/nlohmann_json is then a complete copy of this source tree.","title":"Supporting Both"},{"location":"integration/package_managers/","text":"Package Managers \u00b6 Throughout this page, we will describe how to compile the example file example.cpp below. #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Homebrew \u00b6 If you are using OS X and Homebrew , just type brew tap nlohmann/json brew install nlohmann_json and you're set. If you want the bleeding edge rather than the latest release, use brew tap nlohmann/json brew install nlohmann_json --HEAD instead. Example Create the following file: example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Install the package brew tap nlohmann/json brew install nlohmann_json Determine the include path, which defaults to /usr/local/Cellar/nlohmann_json/$version/include , where $version is the version of the library, e.g. 3.7.3 . The path of the library can be determined with brew list nlohmann_json Compile the code. For instance, the code can be compiled using Clang with clang++ example.cpp -I/usr/local/Cellar/nlohmann_json/3.7.3/include -std = c++11 -o example Meson \u00b6 If you are using the Meson Build System , add this source tree as a meson subproject . You may also use the include.zip published in this project's Releases to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from Meson WrapDB , or simply use meson wrap install nlohmann_json . Please see the meson project for any issues regarding the packaging. The provided meson.build can also be used as an alternative to cmake for installing nlohmann_json system-wide in which case a pkg-config file is installed. To use it, simply have your build system require the nlohmann_json pkg-config dependency. In Meson, it is preferred to use the dependency() object with a subproject fallback, rather than using the subproject directly. Conan \u00b6 If you are using Conan to manage your dependencies, merely add nlohmann_json/x.y.z to your conanfile 's requires, where x.y.z is the release version you want to use. Please file issues here if you experience problems with the packages. Example Create the following files: Conanfile.txt [requires] nlohmann_json/3.7.3 [generators] cmake CMakeLists.txt project ( json_example ) cmake_minimum_required ( VERSION 2.8.12 ) add_definitions ( \"-std=c++11\" ) include ( ${ CMAKE_BINARY_DIR } /conanbuildinfo.cmake ) conan_basic_setup () add_executable ( json_example example.cpp ) target_link_libraries ( json_example ${ CONAN_LIBS } ) example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Build: mkdir build cd build conan install .. cmake .. cmake --build . Spack \u00b6 If you are using Spack to manage your dependencies, you can use the nlohmann-json package . Please see the spack project for any issues regarding the packaging. Hunter \u00b6 If you are using hunter on your project for external dependencies, then you can use the nlohmann_json package . Please see the hunter project for any issues regarding the packaging. Buckaroo \u00b6 If you are using Buckaroo , you can install this library's module with buckaroo add github.com/buckaroo-pm/nlohmann-json . Please file issues here . There is a demo repo here . vcpkg \u00b6 If you are using vcpkg on your project for external dependencies, then you can use the nlohmann-json package . Please see the vcpkg project for any issues regarding the packaging. cget \u00b6 If you are using cget , you can install the latest development version with cget install nlohmann/json . A specific version can be installed with cget install nlohmann/json@v3.1.0 . Also, the multiple header version can be installed by adding the -DJSON_MultipleHeaders=ON flag (i.e., cget install nlohmann/json -DJSON_MultipleHeaders=ON ). CocoaPods \u00b6 If you are using CocoaPods , you can use the library by adding pod \"nlohmann_json\", '~>3.1.2' to your podfile (see an example ). Please file issues here . NuGet \u00b6 If you are using NuGet , you can use the package nlohmann.json . Please check this extensive description on how to use the package. Please files issues here . Conda \u00b6 If you are using conda , you can use the package nlohmann_json from conda-forge executing conda install -c conda-forge nlohmann_json . Please file issues here . MSYS2 \u00b6 If you are using MSYS2 , your can use the mingw-w64-nlohmann-json package, just type pacman -S mingw-w64-i686-nlohmann-json or pacman -S mingw-w64-x86_64-nlohmann-json for installation. Please file issues here if you experience problems with the packages. build2 \u00b6 If you are using build2 , you can use the nlohmann-json package from the public repository http://cppget.org or directly from the package's sources repository . In your project's manifest file, just add depends: nlohmann-json (probably with some version constraints ). If you are not familiar with using dependencies in build2 , please read this introduction . Please file issues here if you experience problems with the packages. wsjcpp \u00b6 If you are using wsjcpp , you can use the command wsjcpp install \"https://github.com/nlohmann/json:develop\" to get the latest version. Note you can change the branch \":develop\" to an existing tag or another branch.","title":"Package Managers"},{"location":"integration/package_managers/#package-managers","text":"Throughout this page, we will describe how to compile the example file example.cpp below. #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; }","title":"Package Managers"},{"location":"integration/package_managers/#homebrew","text":"If you are using OS X and Homebrew , just type brew tap nlohmann/json brew install nlohmann_json and you're set. If you want the bleeding edge rather than the latest release, use brew tap nlohmann/json brew install nlohmann_json --HEAD instead. Example Create the following file: example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Install the package brew tap nlohmann/json brew install nlohmann_json Determine the include path, which defaults to /usr/local/Cellar/nlohmann_json/$version/include , where $version is the version of the library, e.g. 3.7.3 . The path of the library can be determined with brew list nlohmann_json Compile the code. For instance, the code can be compiled using Clang with clang++ example.cpp -I/usr/local/Cellar/nlohmann_json/3.7.3/include -std = c++11 -o example","title":"Homebrew"},{"location":"integration/package_managers/#meson","text":"If you are using the Meson Build System , add this source tree as a meson subproject . You may also use the include.zip published in this project's Releases to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from Meson WrapDB , or simply use meson wrap install nlohmann_json . Please see the meson project for any issues regarding the packaging. The provided meson.build can also be used as an alternative to cmake for installing nlohmann_json system-wide in which case a pkg-config file is installed. To use it, simply have your build system require the nlohmann_json pkg-config dependency. In Meson, it is preferred to use the dependency() object with a subproject fallback, rather than using the subproject directly.","title":"Meson"},{"location":"integration/package_managers/#conan","text":"If you are using Conan to manage your dependencies, merely add nlohmann_json/x.y.z to your conanfile 's requires, where x.y.z is the release version you want to use. Please file issues here if you experience problems with the packages. Example Create the following files: Conanfile.txt [requires] nlohmann_json/3.7.3 [generators] cmake CMakeLists.txt project ( json_example ) cmake_minimum_required ( VERSION 2.8.12 ) add_definitions ( \"-std=c++11\" ) include ( ${ CMAKE_BINARY_DIR } /conanbuildinfo.cmake ) conan_basic_setup () add_executable ( json_example example.cpp ) target_link_libraries ( json_example ${ CONAN_LIBS } ) example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Build: mkdir build cd build conan install .. cmake .. cmake --build .","title":"Conan"},{"location":"integration/package_managers/#spack","text":"If you are using Spack to manage your dependencies, you can use the nlohmann-json package . Please see the spack project for any issues regarding the packaging.","title":"Spack"},{"location":"integration/package_managers/#hunter","text":"If you are using hunter on your project for external dependencies, then you can use the nlohmann_json package . Please see the hunter project for any issues regarding the packaging.","title":"Hunter"},{"location":"integration/package_managers/#buckaroo","text":"If you are using Buckaroo , you can install this library's module with buckaroo add github.com/buckaroo-pm/nlohmann-json . Please file issues here . There is a demo repo here .","title":"Buckaroo"},{"location":"integration/package_managers/#vcpkg","text":"If you are using vcpkg on your project for external dependencies, then you can use the nlohmann-json package . Please see the vcpkg project for any issues regarding the packaging.","title":"vcpkg"},{"location":"integration/package_managers/#cget","text":"If you are using cget , you can install the latest development version with cget install nlohmann/json . A specific version can be installed with cget install nlohmann/json@v3.1.0 . Also, the multiple header version can be installed by adding the -DJSON_MultipleHeaders=ON flag (i.e., cget install nlohmann/json -DJSON_MultipleHeaders=ON ).","title":"cget"},{"location":"integration/package_managers/#cocoapods","text":"If you are using CocoaPods , you can use the library by adding pod \"nlohmann_json\", '~>3.1.2' to your podfile (see an example ). Please file issues here .","title":"CocoaPods"},{"location":"integration/package_managers/#nuget","text":"If you are using NuGet , you can use the package nlohmann.json . Please check this extensive description on how to use the package. Please files issues here .","title":"NuGet"},{"location":"integration/package_managers/#conda","text":"If you are using conda , you can use the package nlohmann_json from conda-forge executing conda install -c conda-forge nlohmann_json . Please file issues here .","title":"Conda"},{"location":"integration/package_managers/#msys2","text":"If you are using MSYS2 , your can use the mingw-w64-nlohmann-json package, just type pacman -S mingw-w64-i686-nlohmann-json or pacman -S mingw-w64-x86_64-nlohmann-json for installation. Please file issues here if you experience problems with the packages.","title":"MSYS2"},{"location":"integration/package_managers/#build2","text":"If you are using build2 , you can use the nlohmann-json package from the public repository http://cppget.org or directly from the package's sources repository . In your project's manifest file, just add depends: nlohmann-json (probably with some version constraints ). If you are not familiar with using dependencies in build2 , please read this introduction . Please file issues here if you experience problems with the packages.","title":"build2"},{"location":"integration/package_managers/#wsjcpp","text":"If you are using wsjcpp , you can use the command wsjcpp install \"https://github.com/nlohmann/json:develop\" to get the latest version. Note you can change the branch \":develop\" to an existing tag or another branch.","title":"wsjcpp"}]}